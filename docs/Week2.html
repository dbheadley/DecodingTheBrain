<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Week 2 – Decoding The Brain</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Decoding The Brain</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.qmd"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Week1.html"> 
<span class="menu-text">Week 1</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./Week2.html" aria-current="page"> 
<span class="menu-text">Week 2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Week3.html"> 
<span class="menu-text">Week3</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="./about.qmd"> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-we-will-cover" id="toc-what-we-will-cover" class="nav-link active" data-scroll-target="#what-we-will-cover">What we will cover</a></li>
  <li><a href="#acquisition-of-eeg" id="toc-acquisition-of-eeg" class="nav-link" data-scroll-target="#acquisition-of-eeg">Acquisition of EEG</a>
  <ul class="collapse">
  <li><a href="#eeg-signal" id="toc-eeg-signal" class="nav-link" data-scroll-target="#eeg-signal">EEG signal</a></li>
  <li><a href="#electrode-placement" id="toc-electrode-placement" class="nav-link" data-scroll-target="#electrode-placement">Electrode placement</a></li>
  <li><a href="#referencing" id="toc-referencing" class="nav-link" data-scroll-target="#referencing">Referencing</a></li>
  <li><a href="#loading-and-inspecting-the-eeg" id="toc-loading-and-inspecting-the-eeg" class="nav-link" data-scroll-target="#loading-and-inspecting-the-eeg">Loading and inspecting the EEG</a></li>
  <li><a href="#time-series-statistics" id="toc-time-series-statistics" class="nav-link" data-scroll-target="#time-series-statistics">Time series statistics</a></li>
  <li><a href="#artifacts-and-noise" id="toc-artifacts-and-noise" class="nav-link" data-scroll-target="#artifacts-and-noise">Artifacts and noise</a></li>
  <li><a href="#a-simple-model-of-the-eeg-signal" id="toc-a-simple-model-of-the-eeg-signal" class="nav-link" data-scroll-target="#a-simple-model-of-the-eeg-signal">A simple model of the EEG signal</a></li>
  </ul></li>
  <li><a href="#evoked-response-potentials" id="toc-evoked-response-potentials" class="nav-link" data-scroll-target="#evoked-response-potentials">Evoked response potentials</a>
  <ul class="collapse">
  <li><a href="#calculating-erps" id="toc-calculating-erps" class="nav-link" data-scroll-target="#calculating-erps">Calculating ERPs</a></li>
  </ul></li>
  <li><a href="#intersubject-variability" id="toc-intersubject-variability" class="nav-link" data-scroll-target="#intersubject-variability">Intersubject variability</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Week 2</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The most accessible way to measure brain activity is using electrodes placed on the scalp, referred to as electroencephalography (EEG). These are weak signals, on the order of 10s of microvolts (uV), which is ~100,000 times weaker than the voltage of a AAA battery. To measure these we use specialized electrodes and amplifiers. We will only briefly discuss these since this course is focused on the signal processing and data analysis end of BCI.</p>
<section id="what-we-will-cover" class="level2">
<h2 class="anchored" data-anchor-id="what-we-will-cover">What we will cover</h2>
<ol type="1">
<li>How EEG signals are acquired</li>
<li>Loading them with Python</li>
<li>Preprocessing and cleaning them</li>
<li>Extracting event-related potentials</li>
</ol>
<div id="fcaa81fb" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pickle</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os.path <span class="im">as</span> op</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.io <span class="im">as</span> sio</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.signal <span class="im">as</span> ss</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> st</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="acquisition-of-eeg" class="level2">
<h2 class="anchored" data-anchor-id="acquisition-of-eeg">Acquisition of EEG</h2>
<p>EEG was one of the first widely accessible ways to track the activity of awake behaving subjects. It was developed in the 1920s by Hans Berger. He found that by inserting metal electrodes into the scalp, he was able to detect extremely weak electrical signals. While initially dismissed by the scientific community, his work was subsequently validated by the prominent neurophysiologist E.D. Adrien. Given the ease of obtaining the EEG signal, and that it did not require opening up the skull, it rapidly became a widespread tool for the study of brain activity. Today, it is commonly used in medicine to help diagnose medical conditions, such as epilepsy, characterize sleep disturbances using polysomnography, and in research labs to further our understanding of brain function. It is also a technique for studying brain activity that is readily accessible to the amateur, with many companies selling do-it-yourself EEG recording kits (e.g.&nbsp;<a href="https://openbci.com/">OpenBCI</a>). For a thorough manual on acquiring and interpreting EEG signals check out <a href="https://academic.oup.com/book/35515">Niedermeyer’s Electroencephalography book</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/EEGElectrodes.png" class="img-fluid figure-img"></p>
<figcaption>EEG electrodes</figcaption>
</figure>
</div>
<section id="eeg-signal" class="level3">
<h3 class="anchored" data-anchor-id="eeg-signal">EEG signal</h3>
<p>As we reviewed in Week 1, the transmembrane currents of neurons produce voltages that can be picked up by electrodes. As those electrodes are moved farther away from the neurons, this voltage falls off. When the electrode reaches the surface of the scalp, the voltage from any individual neuron is so weak that it cannot be distinguished from another. Instead, it is the shared transmembrane currents across all the neurons within several centimeters of the electrode that make up the EEG signal. At the end of last week we saw that the very large currents arising from action potentials independently firing in single neurons were not visible once we were 2 cm away from them. However the weaker, but shared, synaptic currents were evident. It is estimated that the total area of cortex required to be coactivated sufficiently to generate a detectable scalp potential is around 6 cm<sup>2</sup> (Ebersole 1997). Consequently, the EEG reflects widespread activation of cortical tissue.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/1st-eeg.png" class="img-fluid figure-img"></p>
<figcaption>EEG signal</figcaption>
</figure>
</div>
<p>Our simplified model ignored a few details that apply to real brains and that influence the EEG. First, neurons are not ‘point-sources’, i.e.&nbsp;they are not a single current source but have dendrites that currents also flow through. This create a dipole that influences the distribution of transmembrane currents and the voltages recorded at the scalp.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/Neuron_dipole.png" class="img-fluid figure-img"></p>
<figcaption>neuron dipole</figcaption>
</figure>
</div>
<p>Second, the cortex is not a flat sheet of neurons but instead has a convoluted surface, with neurons oriented at different angles with respect to the scalp. This angling affects both the magnitude and the sign of voltage picked up on the scalp, making it exceptionally difficult to reconstruct exactly what neural sources generated any recorded potential.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/EEG_gyri.png" class="img-fluid figure-img"></p>
<figcaption>cortical convolutions</figcaption>
</figure>
</div>
<p>Lastly, we assumed that the conductivity of the tissue between the neuron and the scalp electrode was Ohmic (homogeneous), but this is not the case. A neural potential passes through brain tissue, the cerebrospinal fluid, dura mater that encapsulates the brain, bone of the skull, and the skin. These tissues have different conductivities, further complicating the reconstruction of the underlying neural generators.</p>
</section>
<section id="electrode-placement" class="level3">
<h3 class="anchored" data-anchor-id="electrode-placement">Electrode placement</h3>
<p>The electrodes used in EEG research are small metal discs that are pressed into a conductive gel resting on the scalp. This gel allows electrical activity on the scalp to easily conduct to the electrode. Often the skin under the gel has to be abraded a bit to remove the top layer of dead skin cells and oil that have low conductivity.</p>
<p>While it is not possible to exactly reconstruct the EEG sources, by placing multiple electrodes across the scalp one can observe some coarse localization of brain activity (see <a href="https://robertoostenveld.nl/electrode/#jasper1958">here</a> for a nice discussion). For instance, presenting an auditory stimulus elicits a potential over the portion of the scalp overlying the temporal lobe, where auditory cortex is, while visual stimuli elicit potentials over occipital cortex, where visual cortex is. So, there seems to be some loose relationship between a signal in the EEG and the source of that signal. This highlights the need to place multiple electrodes over the scalp to get a complete picture of the brain activity.</p>
<p>In 1958 a standard was adopted for placement and naming of EEG electrodes with respect to features on the skull. It has been updated periodically over the decades (<a href="https://journals.lww.com/clinicalneurophys/Citation/1994/01000/Guideline_Thirteen__Guidelines_for_Standard.14.aspx">Guidelines for Standard Electrode Position Nomenclature</a>), with the most recent incarnation known as the 10-20 system. The 10 refers to the percent distance between adjacent electrodes along the front-back axis of the skull (also referred to as rostro-caudal or anterior-posterior). 20 refers to the percent distance between adjacent electrodes along the left-right axis of the skull (also referred to as medial-lateral). Electrodes are named with a combination of letters and numbers. Each starts with letters corresponding to the region of the brain they lie immediately over:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Brain region</th>
<th>Lettered indicator</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Prefrontal</td>
<td>Fp</td>
</tr>
<tr class="even">
<td>Frontal</td>
<td>F</td>
</tr>
<tr class="odd">
<td>Central</td>
<td>C</td>
</tr>
<tr class="even">
<td>Temporal</td>
<td>T</td>
</tr>
<tr class="odd">
<td>Parietal</td>
<td>P</td>
</tr>
<tr class="even">
<td>Occipital</td>
<td>O</td>
</tr>
</tbody>
</table>
<p>Each is followed by a number or the letter ‘z’. ‘z’ is used for sites along the midline, even numbers on the right hemisphere, and odd numbers on the left hemisphere. The numbers start at 1 and increase as electrode sites are moved away from the midline, i.e.&nbsp;laterally. This layout looks like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/EEG_10-20.png" class="img-fluid figure-img"></p>
<figcaption>EEG placement</figcaption>
</figure>
</div>
<p>Recently, the number of recording sites has increased because of advances the miniaturization of recording systems. The recordings we will draw from for these lectures use the 10-20 extended system, that features more recording sites. In addition to the names used above, also included are sites that are equally close to two areas and will have their letters joined, e.g.&nbsp;FC (frontal-central) and PO (parietal-occipital). Its layout is:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/EEG_10-10_system_with_additional_information.png" class="img-fluid figure-img"></p>
<figcaption>EEG placement of 10-10</figcaption>
</figure>
</div>
<p>Besides the electrodes that are explicitly targeted to record brain activity, additional electrodes are used for referencing and detection of contaminating noise and artifacts.</p>
</section>
<section id="referencing" class="level3">
<h3 class="anchored" data-anchor-id="referencing">Referencing</h3>
<p>Since voltage is a measure of the work needed to move a charge from one place to another, it is always measured between two points. The point whose signal we seek to measure is referred to as the <em>active</em> site. It is measured with respect to another point, the <em>ground</em>. Ideally, the ground would be at a point in space that is infinitely far away from the electrode and with no charges near it to contaminate the potential we are attempting to measure at the EEG site. This is not practical (nor would it work due to limitations in electronic hardware). Instead, researchers often place the ground immediately behind the ear (referred to as the mastoid). If we only measured our signal at the active site then we face a new problem: there are numerous sources of environmental electrical noise that envelope the entire head, such as emissions from the AC power in the walls. To eliminate that, one also records from a <em>reference</em> electrode, whose signal is subtracted from the active. Any signal that is shared between the active and reference sites is removed (which includes signal at the ground site, since both the active and reference are measured relative to the same ground electrode). The degree of removal is referred to as the <em>common-mode rejection ratio</em> and depends on the quality of the amplifiers and conductivity between the electrodes and scalp. A good common-mode rejection ratio is 70 decibels (dB), which means that the shared signal is reduced by a factor of 10,000,000 (<span class="math inline">dB = 10log_{10}(x)</span>)!</p>
</section>
<section id="loading-and-inspecting-the-eeg" class="level3">
<h3 class="anchored" data-anchor-id="loading-and-inspecting-the-eeg">Loading and inspecting the EEG</h3>
<p>What does the EEG signal look like? Let’s load and visualize some EEG data.</p>
<p>The datasets we will work with are structured in a standardized way, which should make it easy to adapt our code between them. This data is coming from <a href="https://openneuro.org">openneuro.org</a>, a public repository of neural activity recordings from humans across a range of measures (e.g.&nbsp;EEG, MEG, fMRI). We will focus on EEG datasets.</p>
<p>Each dataset is organized as a collection of nested directories. In the top most directory we have a README file that gives details about how the EEG was recorded and the tasks that subjects performed during the recording. For the <a href="https://openneuro.org/datasets/ds003690/versions/1.0.0">one</a> we will work with over the next few weeks, they recorded responses to auditory and visual stimuli under under a variety of conditions.</p>
<p>Each subject will have their own subdirectory, which contains directories for different aspects of the experiment. There should be one labeled ‘eeg’, where the eeg data is. Sometimes you also see a ‘beh’ folder, which has the behavior of the subject. Within the eeg folder we will focus on the *.set files. These are produced by the EEGLAB toolbox in MATLAB and contain both the EEG data and additional data about electrode names, referencing, etc.</p>
<p>To load the set file, we use the <code>loadmat</code> method in the Scipy IO package.</p>
<div id="ee4d2e1a" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load the a .set file</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>subj <span class="op">=</span> <span class="st">'sub-AB58'</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>data_dir <span class="op">=</span> [<span class="st">'.'</span>, <span class="st">'data'</span>, <span class="st">'eeg'</span>, <span class="st">'ds003690'</span>, subj, <span class="st">'eeg'</span>, <span class="st">'</span><span class="sc">{}</span><span class="st">_task-passive_run-1_eeg.set'</span>.<span class="bu">format</span>(subj)]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>eeg_file <span class="op">=</span> op.join(<span class="op">*</span>data_dir) <span class="co"># use * to unpack the list</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>eeg <span class="op">=</span> sio.loadmat(eeg_file, appendmat<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A few notes about the file paths and names. In the course directory we include a ‘data’ directory that contains folders to the datasets we want to work with. This allows us to use a <em>relative file path</em>, where we don’t have to specify the entire list of directories that lead up the the one we are presently in (known as the <em>absolute file path</em>). This improves portability of the code, because someone else could put this on their computer and not have to change the file path. Another thing we do is specify the directories as a list of strings, and use the <code>join</code> function in the python <code>os</code> package to paste these together into a file name. This is because depending on whether you are running the code on a Windows, Mac, or Linux computer, the directory separator will be different (‘\’ for windows, ‘/’ for Max and Linux).</p>
<p>In the course directory we have a folder ‘data’ , which contains all the data files for this course.</p>
<p>Another thing to notice is that the file names are descriptive. For the .set file above, the subject name (‘sub-AB58’), task (‘task-passive’), and experimental run (‘run-1’), and data type (‘eeg’) are given. These are separated by underscores. This standard formulation makes it easier to quickly look at the files in a directory and determine which ones are relevant to us and write code that automatically accesses files from specific subjects or tasks.</p>
<p>Once the eeg data is loaded in, we should inspect it to determine its data type and contents.</p>
<div id="bd3cea6e" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get data type</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(eeg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>dict</code></pre>
</div>
</div>
<p>The eeg data returned by the <code>loadmat</code> function is a dictionary type. Just to refresh, a dictionary is a data type in python containing a collection of <em>keys</em>, where each key is associated with a <em>value</em>.</p>
<div id="f64f4741" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get keys</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>eeg.keys()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>dict_keys(['__header__', '__version__', '__globals__', 'setname', 'filename', 'filepath', 'subject', 'group', 'condition', 'session', 'comments', 'nbchan', 'trials', 'pnts', 'srate', 'xmin', 'xmax', 'times', 'data', 'icaact', 'icawinv', 'icasphere', 'icaweights', 'icachansind', 'chanlocs', 'urchanlocs', 'chaninfo', 'ref', 'event', 'urevent', 'eventdescription', 'epoch', 'epochdescription', 'reject', 'stats', 'specdata', 'specicaact', 'splinefile', 'icasplinefile', 'dipfit', 'history', 'saved', 'etc', 'datfile', 'run'])</code></pre>
</div>
</div>
<p>If you go through the keys, some of these are self-explanatory and give information about the experiment. These are not always filled in, so don’t depend on them. Instead, we will focus on:</p>
<ul>
<li>‘srate’ - the sample rate in Hz. This is how many voltage measurements were made each second per EEG site</li>
<li>‘data’ - the EEG data</li>
<li>‘chaninfo’ - the names of the eeg data channels. We can use these to determine where each EEG signal came from.</li>
<li>‘ref’ - where the reference channel is</li>
</ul>
<p>Let’s see what their data types are and their values. We will create a simple function, <code>var_inspector</code>, to display the data type and values of each variable.</p>
<div id="92e21f66" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> var_inspector(var):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'Type: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(<span class="bu">type</span>(var)))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(var)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># srate</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>srate <span class="op">=</span> eeg[<span class="st">'srate'</span>]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>var_inspector(srate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Type: &lt;class 'numpy.ndarray'&gt;
[[500]]</code></pre>
</div>
</div>
<p><em>srate</em> is a 2-D numpy array with a single value. To pull out just the numeric value, we index into the numpy array:</p>
<div id="cdcaae2c" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>srate <span class="op">=</span> srate[<span class="dv">0</span>,<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next we will get the <em>chaninfo</em> data.</p>
<div id="a9788127" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>chan_info <span class="op">=</span> eeg[<span class="st">'chaninfo'</span>]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>var_inspector(chan_info)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Type: &lt;class 'numpy.ndarray'&gt;
[[(array(['D:\\ProjectAgingNeuromodulation\\AuditoryResearch\\EEGLAB_analysis\\chanlocs_corrected\\AB58_locs_corrected.DAT'],
        dtype='&lt;U106'), array(['Fp1 69 -2.854012 12.903291 -1.520481 ',
         'Fpz 69 0.583218 13.494058 -1.592608  ',
         'Fp2 69 3.935400 12.477923 -2.102277  ',
         'AF3 69 -3.023524 12.428141 1.361401  ',
         'AF4 69 4.304501 11.727693 0.427403   ',
         'F7 69 -6.639328 8.170529 -1.526560   ',
         'F5 69 -5.876012 9.542894 0.800148    ',
         'F3 69 -4.229360 10.265764 2.418731   ',
         'F1 69 -1.882614 11.018632 4.587177   ',
         'Fz 69 0.596303 10.217070 4.293318    ',
         'F2 69 3.996278 10.694478 3.944555    ',
         'F4 69 5.631967 9.848669 2.084015     ',
         'F6 69 6.969560 8.879675 -0.060155    ',
         'F8 69 7.878357 7.523402 -2.148623    ',
         'FT7 69 -7.918441 5.400486 -0.685157  ',
         'FC5 69 -6.848348 6.444450 1.872787   ',
         'FC3 69 -5.007377 6.820720 4.378383   ',
         'FC1 69 -2.332303 7.275606 6.020996   ',
         'FCz 69 0.892164 7.275017 6.676030    ',
         'FC2 69 3.868832 7.218509 5.929260    ',
         'FC4 69 6.393416 6.765655 4.161855    ',
         'FC6 69 8.110071 5.963853 1.523854    ',
         'FT8 69 8.880818 4.564967 -1.282408   ',
         'T7 69 -8.341170 2.798480 0.226452    ',
         'C5 69 -7.438693 3.373324 3.054235    ',
         'C3 69 -5.931186 3.709710 6.488027    ',
         'C1 69 -2.569554 3.746717 7.996653    ',
         'Cz 69 1.032521 3.911274 8.476038     ',
         'C2 69 4.350667 3.569207 7.594067     ',
         'C4 69 6.801077 3.610167 5.548478     ',
         'C6 69 9.023433 2.739705 2.800857     ',
         'T8 69 8.986069 1.829011 -0.226452    ',
         'M1 69 -7.644597 -0.549069 -8.007587  ',
         'TP7 69 -8.254624 -0.373276 1.011124  ',
         'CP5 69 -7.370408 0.278624 4.028963   ',
         'CP3 69 -5.316664 0.049608 6.245472   ',
         'CP1 69 -2.702063 0.250874 8.319883   ',
         'CPz 69 0.627199 -0.010582 8.411424   ',
         'CP2 69 4.188373 -0.366793 7.784681   ',
         'CP4 69 6.730657 -0.589212 6.652807   ',
         'CP6 69 8.320402 -0.371316 3.731920   ',
         'TP8 69 8.799763 -0.721895 0.744581   ',
         'M2 69 7.864402 -0.341263 -8.226876   ',
         'P7 69 -7.147690 -2.857133 1.425296   ',
         'P5 69 -5.896095 -3.084760 3.659961   ',
         'P3 69 -3.990392 -3.311368 5.491853   ',
         'P1 69 -1.790996 -3.225753 6.718182   ',
         'Pz 69 0.559499 -2.994738 7.218447    ',
         'P2 69 2.982983 -3.442504 6.627176    ',
         'P4 69 5.367558 -3.552835 5.125538    ',
         'P6 69 6.927846 -3.798552 3.392559    ',
         'P8 69 7.864575 -3.658688 1.023157    ',
         'PO7 69 -5.260816 -5.210424 1.680544  ',
         'PO5 69 -3.805657 -5.398441 3.520525  ',
         'PO3 69 -1.695287 -5.760008 4.798353  ',
         'POz 69 0.620948 -5.819869 5.205846   ',
         'PO4 69 2.894593 -5.904253 4.664386   ',
         'PO6 69 4.777563 -6.086181 3.030508   ',
         'PO8 69 6.204419 -5.931612 1.100191   ',
         'CB1 69 -2.746747 -7.905792 0.181570  ',
         'O1 69 -2.994389 -7.100698 1.760379   ',
         'Oz 69 0.396758 -7.928689 2.063318    ',
         'O2 69 3.565017 -7.643452 1.469474    ',
         'CB2 69 3.304482 -8.550863 -0.418131  ',
         'VEO 69 -4.985376 9.402884 -3.997588  ',
         'HEO 69 -6.256028 5.891592 -6.051630  ',
         'EKG 69 -6.121837 -3.762735 -10.496158',
         'EMG 69 -5.970550 -4.868990 -11.655138'], dtype='&lt;U37'), array([], shape=(0, 0), dtype=uint8), array([], shape=(0, 0), dtype=uint8), array(['+X'], dtype='&lt;U2'), array([], shape=(0, 0), dtype=uint8), array([], shape=(0, 0), dtype=uint8), array([], shape=(0, 0), dtype=uint8))]]</code></pre>
</div>
</div>
<p>It is a bit more complicated. This is a numpy array of numpy arrays of strings.</p>
<div id="2acc7486" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get the channel names</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>chan_info <span class="op">=</span> chan_info[<span class="dv">0</span>,<span class="dv">0</span>][<span class="dv">1</span>]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>var_inspector(chan_info)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Type: &lt;class 'numpy.ndarray'&gt;
['Fp1 69 -2.854012 12.903291 -1.520481 '
 'Fpz 69 0.583218 13.494058 -1.592608  '
 'Fp2 69 3.935400 12.477923 -2.102277  '
 'AF3 69 -3.023524 12.428141 1.361401  '
 'AF4 69 4.304501 11.727693 0.427403   '
 'F7 69 -6.639328 8.170529 -1.526560   '
 'F5 69 -5.876012 9.542894 0.800148    '
 'F3 69 -4.229360 10.265764 2.418731   '
 'F1 69 -1.882614 11.018632 4.587177   '
 'Fz 69 0.596303 10.217070 4.293318    '
 'F2 69 3.996278 10.694478 3.944555    '
 'F4 69 5.631967 9.848669 2.084015     '
 'F6 69 6.969560 8.879675 -0.060155    '
 'F8 69 7.878357 7.523402 -2.148623    '
 'FT7 69 -7.918441 5.400486 -0.685157  '
 'FC5 69 -6.848348 6.444450 1.872787   '
 'FC3 69 -5.007377 6.820720 4.378383   '
 'FC1 69 -2.332303 7.275606 6.020996   '
 'FCz 69 0.892164 7.275017 6.676030    '
 'FC2 69 3.868832 7.218509 5.929260    '
 'FC4 69 6.393416 6.765655 4.161855    '
 'FC6 69 8.110071 5.963853 1.523854    '
 'FT8 69 8.880818 4.564967 -1.282408   '
 'T7 69 -8.341170 2.798480 0.226452    '
 'C5 69 -7.438693 3.373324 3.054235    '
 'C3 69 -5.931186 3.709710 6.488027    '
 'C1 69 -2.569554 3.746717 7.996653    '
 'Cz 69 1.032521 3.911274 8.476038     '
 'C2 69 4.350667 3.569207 7.594067     '
 'C4 69 6.801077 3.610167 5.548478     '
 'C6 69 9.023433 2.739705 2.800857     '
 'T8 69 8.986069 1.829011 -0.226452    '
 'M1 69 -7.644597 -0.549069 -8.007587  '
 'TP7 69 -8.254624 -0.373276 1.011124  '
 'CP5 69 -7.370408 0.278624 4.028963   '
 'CP3 69 -5.316664 0.049608 6.245472   '
 'CP1 69 -2.702063 0.250874 8.319883   '
 'CPz 69 0.627199 -0.010582 8.411424   '
 'CP2 69 4.188373 -0.366793 7.784681   '
 'CP4 69 6.730657 -0.589212 6.652807   '
 'CP6 69 8.320402 -0.371316 3.731920   '
 'TP8 69 8.799763 -0.721895 0.744581   '
 'M2 69 7.864402 -0.341263 -8.226876   '
 'P7 69 -7.147690 -2.857133 1.425296   '
 'P5 69 -5.896095 -3.084760 3.659961   '
 'P3 69 -3.990392 -3.311368 5.491853   '
 'P1 69 -1.790996 -3.225753 6.718182   '
 'Pz 69 0.559499 -2.994738 7.218447    '
 'P2 69 2.982983 -3.442504 6.627176    '
 'P4 69 5.367558 -3.552835 5.125538    '
 'P6 69 6.927846 -3.798552 3.392559    '
 'P8 69 7.864575 -3.658688 1.023157    '
 'PO7 69 -5.260816 -5.210424 1.680544  '
 'PO5 69 -3.805657 -5.398441 3.520525  '
 'PO3 69 -1.695287 -5.760008 4.798353  '
 'POz 69 0.620948 -5.819869 5.205846   '
 'PO4 69 2.894593 -5.904253 4.664386   '
 'PO6 69 4.777563 -6.086181 3.030508   '
 'PO8 69 6.204419 -5.931612 1.100191   '
 'CB1 69 -2.746747 -7.905792 0.181570  '
 'O1 69 -2.994389 -7.100698 1.760379   '
 'Oz 69 0.396758 -7.928689 2.063318    '
 'O2 69 3.565017 -7.643452 1.469474    '
 'CB2 69 3.304482 -8.550863 -0.418131  '
 'VEO 69 -4.985376 9.402884 -3.997588  '
 'HEO 69 -6.256028 5.891592 -6.051630  '
 'EKG 69 -6.121837 -3.762735 -10.496158'
 'EMG 69 -5.970550 -4.868990 -11.655138']</code></pre>
</div>
</div>
<p>Each channel is given as a string, with its name followed by a string of numbers, which represent the 3D position of each electrode on the scalp (X, Y, Z). We can break these out using the built in <code>split</code> method associated with the python string object (by the way, to see all the methods available for a string, you can pass the string variable to the <code>dir</code> method).</p>
<div id="846d5e88" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># use split the strings in chan_names by white space</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>chan_names <span class="op">=</span> [name.split()[<span class="dv">0</span>] <span class="cf">for</span> name <span class="kw">in</span> chan_info]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>var_inspector(chan_names)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Channel number: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(<span class="bu">len</span>(chan_names)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Type: &lt;class 'list'&gt;
['Fp1', 'Fpz', 'Fp2', 'AF3', 'AF4', 'F7', 'F5', 'F3', 'F1', 'Fz', 'F2', 'F4', 'F6', 'F8', 'FT7', 'FC5', 'FC3', 'FC1', 'FCz', 'FC2', 'FC4', 'FC6', 'FT8', 'T7', 'C5', 'C3', 'C1', 'Cz', 'C2', 'C4', 'C6', 'T8', 'M1', 'TP7', 'CP5', 'CP3', 'CP1', 'CPz', 'CP2', 'CP4', 'CP6', 'TP8', 'M2', 'P7', 'P5', 'P3', 'P1', 'Pz', 'P2', 'P4', 'P6', 'P8', 'PO7', 'PO5', 'PO3', 'POz', 'PO4', 'PO6', 'PO8', 'CB1', 'O1', 'Oz', 'O2', 'CB2', 'VEO', 'HEO', 'EKG', 'EMG']
Channel number: 68</code></pre>
</div>
</div>
<p>These names should be familiar from our discussion of electrode placement. What about the locations of the channels?</p>
<div id="c094ec9b" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get the channel positions on the scalp</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>chan_locs <span class="op">=</span> [name.split()[<span class="dv">2</span>:] <span class="cf">for</span> name <span class="kw">in</span> chan_info]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># convert chan_locs to numeric data type in a numpy array</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>chan_locs <span class="op">=</span> np.array(chan_locs, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>var_inspector(chan_locs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Type: &lt;class 'numpy.ndarray'&gt;
[[-2.8540120e+00  1.2903291e+01 -1.5204810e+00]
 [ 5.8321800e-01  1.3494058e+01 -1.5926080e+00]
 [ 3.9354000e+00  1.2477923e+01 -2.1022770e+00]
 [-3.0235240e+00  1.2428141e+01  1.3614010e+00]
 [ 4.3045010e+00  1.1727693e+01  4.2740300e-01]
 [-6.6393280e+00  8.1705290e+00 -1.5265600e+00]
 [-5.8760120e+00  9.5428940e+00  8.0014800e-01]
 [-4.2293600e+00  1.0265764e+01  2.4187310e+00]
 [-1.8826140e+00  1.1018632e+01  4.5871770e+00]
 [ 5.9630300e-01  1.0217070e+01  4.2933180e+00]
 [ 3.9962780e+00  1.0694478e+01  3.9445550e+00]
 [ 5.6319670e+00  9.8486690e+00  2.0840150e+00]
 [ 6.9695600e+00  8.8796750e+00 -6.0155000e-02]
 [ 7.8783570e+00  7.5234020e+00 -2.1486230e+00]
 [-7.9184410e+00  5.4004860e+00 -6.8515700e-01]
 [-6.8483480e+00  6.4444500e+00  1.8727870e+00]
 [-5.0073770e+00  6.8207200e+00  4.3783830e+00]
 [-2.3323030e+00  7.2756060e+00  6.0209960e+00]
 [ 8.9216400e-01  7.2750170e+00  6.6760300e+00]
 [ 3.8688320e+00  7.2185090e+00  5.9292600e+00]
 [ 6.3934160e+00  6.7656550e+00  4.1618550e+00]
 [ 8.1100710e+00  5.9638530e+00  1.5238540e+00]
 [ 8.8808180e+00  4.5649670e+00 -1.2824080e+00]
 [-8.3411700e+00  2.7984800e+00  2.2645200e-01]
 [-7.4386930e+00  3.3733240e+00  3.0542350e+00]
 [-5.9311860e+00  3.7097100e+00  6.4880270e+00]
 [-2.5695540e+00  3.7467170e+00  7.9966530e+00]
 [ 1.0325210e+00  3.9112740e+00  8.4760380e+00]
 [ 4.3506670e+00  3.5692070e+00  7.5940670e+00]
 [ 6.8010770e+00  3.6101670e+00  5.5484780e+00]
 [ 9.0234330e+00  2.7397050e+00  2.8008570e+00]
 [ 8.9860690e+00  1.8290110e+00 -2.2645200e-01]
 [-7.6445970e+00 -5.4906900e-01 -8.0075870e+00]
 [-8.2546240e+00 -3.7327600e-01  1.0111240e+00]
 [-7.3704080e+00  2.7862400e-01  4.0289630e+00]
 [-5.3166640e+00  4.9608000e-02  6.2454720e+00]
 [-2.7020630e+00  2.5087400e-01  8.3198830e+00]
 [ 6.2719900e-01 -1.0582000e-02  8.4114240e+00]
 [ 4.1883730e+00 -3.6679300e-01  7.7846810e+00]
 [ 6.7306570e+00 -5.8921200e-01  6.6528070e+00]
 [ 8.3204020e+00 -3.7131600e-01  3.7319200e+00]
 [ 8.7997630e+00 -7.2189500e-01  7.4458100e-01]
 [ 7.8644020e+00 -3.4126300e-01 -8.2268760e+00]
 [-7.1476900e+00 -2.8571330e+00  1.4252960e+00]
 [-5.8960950e+00 -3.0847600e+00  3.6599610e+00]
 [-3.9903920e+00 -3.3113680e+00  5.4918530e+00]
 [-1.7909960e+00 -3.2257530e+00  6.7181820e+00]
 [ 5.5949900e-01 -2.9947380e+00  7.2184470e+00]
 [ 2.9829830e+00 -3.4425040e+00  6.6271760e+00]
 [ 5.3675580e+00 -3.5528350e+00  5.1255380e+00]
 [ 6.9278460e+00 -3.7985520e+00  3.3925590e+00]
 [ 7.8645750e+00 -3.6586880e+00  1.0231570e+00]
 [-5.2608160e+00 -5.2104240e+00  1.6805440e+00]
 [-3.8056570e+00 -5.3984410e+00  3.5205250e+00]
 [-1.6952870e+00 -5.7600080e+00  4.7983530e+00]
 [ 6.2094800e-01 -5.8198690e+00  5.2058460e+00]
 [ 2.8945930e+00 -5.9042530e+00  4.6643860e+00]
 [ 4.7775630e+00 -6.0861810e+00  3.0305080e+00]
 [ 6.2044190e+00 -5.9316120e+00  1.1001910e+00]
 [-2.7467470e+00 -7.9057920e+00  1.8157000e-01]
 [-2.9943890e+00 -7.1006980e+00  1.7603790e+00]
 [ 3.9675800e-01 -7.9286890e+00  2.0633180e+00]
 [ 3.5650170e+00 -7.6434520e+00  1.4694740e+00]
 [ 3.3044820e+00 -8.5508630e+00 -4.1813100e-01]
 [-4.9853760e+00  9.4028840e+00 -3.9975880e+00]
 [-6.2560280e+00  5.8915920e+00 -6.0516300e+00]
 [-6.1218370e+00 -3.7627350e+00 -1.0496158e+01]
 [-5.9705500e+00 -4.8689900e+00 -1.1655138e+01]]</code></pre>
</div>
</div>
<p>Since these were strings, we had to convert them to a numeric data type, especially if we want to eventually use them for plotting.</p>
<div id="852ea568" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_scalp(chan_locs, chan_names, subj):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    ax.scatter(chan_locs[:,<span class="dv">0</span>], chan_locs[:,<span class="dv">1</span>])</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ind, name <span class="kw">in</span> <span class="bu">enumerate</span>(chan_names):</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        ax.text(chan_locs[ind,<span class="dv">0</span>], chan_locs[ind,<span class="dv">1</span>], name)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'Medial-lateral'</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Anterior-posterior'</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="st">'Channel locations for </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(subj))</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>plot_scalp(chan_locs, chan_names, subj)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-12-output-1.png" width="366" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Another useful piece of info in the <em>eeg</em> data is ‘ref’, which tells us the position of the reference electrode.</p>
<div id="fa94390a" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>ref_elec <span class="op">=</span> eeg[<span class="st">'ref'</span>]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>var_inspector(ref_elec)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Type: &lt;class 'numpy.ndarray'&gt;
['between_Cz_and_CPz']</code></pre>
</div>
</div>
<p>This is another numpy array with a string inside. Let’s extract the channels the reference was between, and then use their coordinates to plot where the reference was.</p>
<div id="79b136bb" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># split the reference string at underscores and return the channel names</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>near_ref_names <span class="op">=</span> [ref <span class="cf">for</span> ref <span class="kw">in</span> ref_elec[<span class="dv">0</span>].split(<span class="st">'_'</span>) <span class="cf">if</span> ref <span class="kw">in</span> chan_names]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Reference channel was near: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(near_ref_names))</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co"># get the coordinates of the reference electrodes</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>near_ref_coords <span class="op">=</span> [chan_locs[chan_names.index(ref)] <span class="cf">for</span> ref <span class="kw">in</span> near_ref_names]</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co"># print near ref coords with only 2 decimal places</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Coordinates of electrodes near reference: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(np.<span class="bu">round</span>(near_ref_coords,<span class="dv">2</span>)))   </span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="co"># get the average of the coordinates</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>ref_coord <span class="op">=</span> np.mean(near_ref_coords, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Coordinates of reference: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(np.<span class="bu">round</span>(ref_coord,<span class="dv">2</span>)))</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the reference electrode</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>plot_scalp(chan_locs, chan_names, subj)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>plt.scatter(ref_coord[<span class="dv">0</span>], ref_coord[<span class="dv">1</span>], c<span class="op">=</span><span class="st">'r'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>plt.text(ref_coord[<span class="dv">0</span>], ref_coord[<span class="dv">1</span>], <span class="st">'REF'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Reference channel was near: ['Cz', 'CPz']
Coordinates of electrodes near reference: [[ 1.03  3.91  8.48]
 [ 0.63 -0.01  8.41]]
Coordinates of reference: [0.83 1.95 8.44]</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>Text(0.82986, 1.9503460000000001, 'REF')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-14-output-3.png" width="366" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>With all this out of the way, let’s inspect the EEG data itself.</p>
<div id="38e36ff9" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>eeg_data <span class="op">=</span> eeg[<span class="st">'data'</span>]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>var_inspector(eeg_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Type: &lt;class 'numpy.ndarray'&gt;
[[-17487.854   -17494.352   -17504.037   ... -17945.916   -17952.68
  -17949.879  ]
 [-22107.213   -22104.95    -22108.615   ... -22745.281   -22717.625
  -22711.635  ]
 [ -5888.045    -5887.7466   -5885.6606  ...  -5802.661    -5804.211
   -5797.6245 ]
 ...
 [ -1053.0055   -1051.8431   -1050.8597  ...   -422.0903    -421.13663
    -418.2458 ]
 [     0.           0.           0.      ...      0.           0.
       0.     ]
 [     0.           0.           0.      ...      0.           0.
       0.     ]]</code></pre>
</div>
</div>
<p>Another numpy array, but this one contains a lot of numeric data. We can get the number of channels and time points that were recorded.</p>
<div id="2377fd21" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>nchan <span class="op">=</span> eeg_data.shape[<span class="dv">0</span>]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>nsamp <span class="op">=</span> eeg_data.shape[<span class="dv">1</span>]</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Number of samples: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(nsamp))</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Duration of recording: </span><span class="sc">{}</span><span class="st"> seconds'</span>.<span class="bu">format</span>(nsamp<span class="op">/</span>srate)) <span class="co"># dividing number of samples by sampling rate gives the duration of the recording</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Number of channels: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(nchan))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of samples: 132480
Duration of recording: 264.96 seconds
Number of channels: 66</code></pre>
</div>
</div>
<p>Uh oh, the number of channels, 66, does not match the number given in chaninfo, 68. Perhaps we can find the correct values in the file ‘*_channels.tsv’.</p>
<div id="ca6d49d7" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load the a *_channels.tsv file</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>subj <span class="op">=</span> <span class="st">'sub-AB58'</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>chan_dir <span class="op">=</span> [<span class="st">'.'</span>, <span class="st">'data'</span>, <span class="st">'eeg'</span>, <span class="st">'ds003690'</span>, subj, <span class="st">'eeg'</span>, <span class="st">'</span><span class="sc">{}</span><span class="st">_task-passive_run-1_channels.tsv'</span>.<span class="bu">format</span>(subj)]</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>chan_file <span class="op">=</span> op.join(<span class="op">*</span>chan_dir) <span class="co"># use * to unpack the list</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>channels <span class="op">=</span> pd.read_csv(chan_file, sep<span class="op">=</span><span class="st">'</span><span class="ch">\t</span><span class="st">'</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(channels)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            name   type units
0            AF3    EEG    uV
1            AF4    EEG    uV
2             F7    EEG    uV
3             F5    EEG    uV
4             F3    EEG    uV
..           ...    ...   ...
61           VEO   VEOG    uV
62           HEO   HEOG    uV
63           EKG    ECG    uV
64  R-Dia-X-(mm)  PUPIL    mm
65  R-Dia-Y-(mm)  PUPIL    mm

[66 rows x 3 columns]</code></pre>
</div>
</div>
<p>Notice how the number of channels listed in the .tsv file is the same as those in our EEG data. This is probably the correct file for figuring out where each channel was recorded.</p>
<p>The .tsv file type stands for <em>tab separated values</em>. It is a table of data stored in a text file, where each row is a different line, and each column is separated by a tab. Often the first line of text gives the names for each column, but this is not necessary. It looks like this if you open in a text editor:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tsv_file_in_txt_edit.png" class="img-fluid figure-img"></p>
<figcaption>TSV file viewed in a text editor</figcaption>
</figure>
</div>
<p>It is difficult to compare the list of recording sites in chaninfo and those listed in the channels .tsv file by eye, but we can write some code to solve that problem.</p>
<div id="bb1dc199" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pull the channel names from the channels tsv file</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>chan_names_tsv <span class="op">=</span> channels[<span class="st">'name'</span>].tolist()</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"># identify the channels in chan_names that are not in chan_names_tsv</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>missing_chan <span class="op">=</span> [chan <span class="cf">for</span> chan <span class="kw">in</span> chan_names <span class="cf">if</span> chan <span class="kw">not</span> <span class="kw">in</span> chan_names_tsv]</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The missing channels are: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(<span class="st">', '</span>.join(missing_chan)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The missing channels are: Fp1, Fpz, Fp2, EMG</code></pre>
</div>
</div>
<p>We should set <em>chan_names</em> to the list in the channels .tsv file and match those with the electrode locations from the eeg .set file.</p>
<div id="1ccd9115" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>chan_info <span class="op">=</span> pd.DataFrame({<span class="st">'name'</span>: chan_names, </span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'ML'</span>: chan_locs[:,<span class="dv">0</span>], </span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'AP'</span>: chan_locs[:,<span class="dv">1</span>], </span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'DV'</span>: chan_locs[:,<span class="dv">2</span>]})</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>channels <span class="op">=</span> pd.merge(channels, chan_info, how<span class="op">=</span><span class="st">'left'</span>, on<span class="op">=</span><span class="st">'name'</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>channels</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">name</th>
<th data-quarto-table-cell-role="th">type</th>
<th data-quarto-table-cell-role="th">units</th>
<th data-quarto-table-cell-role="th">ML</th>
<th data-quarto-table-cell-role="th">AP</th>
<th data-quarto-table-cell-role="th">DV</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>AF3</td>
<td>EEG</td>
<td>uV</td>
<td>-3.023524</td>
<td>12.428141</td>
<td>1.361401</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>AF4</td>
<td>EEG</td>
<td>uV</td>
<td>4.304501</td>
<td>11.727693</td>
<td>0.427403</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>F7</td>
<td>EEG</td>
<td>uV</td>
<td>-6.639328</td>
<td>8.170529</td>
<td>-1.526560</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>F5</td>
<td>EEG</td>
<td>uV</td>
<td>-5.876012</td>
<td>9.542894</td>
<td>0.800148</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>F3</td>
<td>EEG</td>
<td>uV</td>
<td>-4.229360</td>
<td>10.265764</td>
<td>2.418731</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">61</td>
<td>VEO</td>
<td>VEOG</td>
<td>uV</td>
<td>-4.985376</td>
<td>9.402884</td>
<td>-3.997588</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">62</td>
<td>HEO</td>
<td>HEOG</td>
<td>uV</td>
<td>-6.256028</td>
<td>5.891592</td>
<td>-6.051630</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">63</td>
<td>EKG</td>
<td>ECG</td>
<td>uV</td>
<td>-6.121837</td>
<td>-3.762735</td>
<td>-10.496158</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">64</td>
<td>R-Dia-X-(mm)</td>
<td>PUPIL</td>
<td>mm</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">65</td>
<td>R-Dia-Y-(mm)</td>
<td>PUPIL</td>
<td>mm</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>66 rows × 6 columns</p>
</div>
</div>
</div>
<p>Note that there are a few extra channels with names that are not part of the EEG site naming scheme given above. ‘VEO’ and ‘HEO’ are electrodes placed near the left eye and can detect eye movements (discussed below). ‘EKG’ is from an electrode place near the heart and gives the <em>electrocardiogram</em>, which captures the electrical activity associated with heart beats. Lastly, ‘R-Dia-X-(mm)’ and ‘R-Dia-Y-(mm)’ are measures of pupil diameter made by a video camera trained on the eye.</p>
<p>And now we can replot the EEG electrodes, with the missing channels removed.</p>
<div id="86b22c0a" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>chan_names <span class="op">=</span> channels[<span class="st">'name'</span>].values</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>chan_locs <span class="op">=</span> channels[[<span class="st">'ML'</span>, <span class="st">'AP'</span>, <span class="st">'DV'</span>]].values</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>plot_scalp(chan_locs, chan_names, subj)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>plt.scatter(ref_coord[<span class="dv">0</span>], ref_coord[<span class="dv">1</span>], c<span class="op">=</span><span class="st">'r'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>plt.text(ref_coord[<span class="dv">0</span>], ref_coord[<span class="dv">1</span>], <span class="st">'REF'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>Text(0.82986, 1.9503460000000001, 'REF')</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>posx and posy should be finite values
posx and posy should be finite values
posx and posy should be finite values
posx and posy should be finite values
posx and posy should be finite values
posx and posy should be finite values</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-20-output-3.png" width="380" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The next thing to inspect is the EEG signal itself. The EEG signal is an array of voltages, <span class="math inline">EEG</span>, sampled at each channel, <span class="math inline">ch</span> and time point, <span class="math inline">t</span>. A single sample can be written as <span class="math inline">EEG_{ch,t}</span>. If we want the voltage across all channels at a specific time that would be the vector <span class="math inline">EEG_{t}</span>. The entire time series of voltages from a single channel is expressed as <span class="math inline">EEG_{ch}</span>. The term <em>time series</em> is important to keep in mind. Virtually all the data we will work with is time series data, meaning that it is the values generated by some process that is sampled at regular intervals. In the case of our present EEG signal, this would be the uV potentials recorded from an electrode at the sample rate (<code>srate</code>) of 500 Hz.</p>
<p>To begin exploring this data, lets plot the voltage detected on channel O1 (an electrode over the occiptal lobe on the left hemisphere) between 50 and 52 seconds. We will express this as: <span class="math display"> EEG_{O1}[50\leq t \le 52] </span></p>
<p>First, we identify the index for the row containing data from channel O1.</p>
<div id="5b3d0afa" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># select channel to plot</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>sel_chan <span class="op">=</span> <span class="st">'O1'</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>chan_ind <span class="op">=</span> channels.index[channels[<span class="st">'name'</span>]<span class="op">==</span>sel_chan]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Using the <code>channels</code> dataframe we generated above, we find the row where the ‘name’ column is equal to O1, and then return the index of that row. The indices in the <code>channels</code> dataframe range from 0 to 65, with each corresponding to a row in <code>eeg_data</code>.</p>
<p>Next we need to find the time points that were sampled between 50 and 52 seconds into the recording.</p>
<div id="1c713f48" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set the times we wish to plot</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>start_t <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>end_t <span class="op">=</span> <span class="dv">52</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>start_idx <span class="op">=</span> (start_t<span class="op">*</span>srate).astype(<span class="bu">int</span>)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>end_idx <span class="op">=</span> (end_t<span class="op">*</span>srate).astype(<span class="bu">int</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Since our recording starts at time point 0 seconds and was recorded with <code>srate</code> number of samples per second, we can find the indices of the start and stop times by multiplying those times in seconds by the <code>srate</code> (<code>start_t*srate</code> and <code>end_t*srate</code>). Since these will be used to index into an array, we ensure that they have integer values by forcing them to an integer datatype using the numpy <code>astype</code> function.</p>
<div id="ada64feb" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># extract the eeg data we wish to plot</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>eeg_epoch <span class="op">=</span> eeg_data[chan_ind, start_idx:end_idx].squeeze() <span class="co"># squeeze removes the extra dimension</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>An ‘epoch’ is a period of time, and when we pull out a contiguous set of values from a time series will refer to that as an epoch. When plotting that data, we need to pass both the eeg signal and their corresponding time points to the plotting function. These can either be <em>absolute</em> or <em>relative</em>. For absolute, the time values are taken with respect to the entire recording, so in our case they would start at 50 sec and end just before 52 sec.&nbsp;For relative time, the times at taken with respect to a specific event (usually the beginning of our epoch, but not always). In that case, they would start at 0 sec and end just before 2 sec.&nbsp;Calculating either is straightforward:</p>
<div id="08a61224" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># time on an absolute scale</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>t_abs_epoch <span class="op">=</span> start_t <span class="op">+</span> np.arange(<span class="dv">0</span>, eeg_epoch.size)<span class="op">/</span>srate</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co"># time on a relative scale</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>t_rel_epoch <span class="op">=</span> np.arange(<span class="dv">0</span>, eeg_epoch.size)<span class="op">/</span>srate</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s plot on both time scales, just for show.</p>
<div id="69a73305" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">4</span>))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(t_abs_epoch, eeg_epoch) <span class="co"># we transpose to make the data the right shape for plotting</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">'Absolute time (s)'</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(t_rel_epoch, eeg_epoch)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'Relative time (s)'</span>)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> for </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(sel_chan, subj))</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-25-output-1.png" width="950" height="381" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>This is the electrical activity recorded on the scalp over the left occipital cortex, an area of the brain involved in visual processing. The signal has a somewhat noisy appearance, though it is unclear what is really ‘noise.’</p>
<p>Before we move on, let’s create a class for loading the EEG data from a file and giving us access to it. This will encompass all the operations we performed above, making it easier to load data from other subjects with the same format.</p>
<div id="92c9e11a" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> EEG:</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, eeg_file, chan_file):</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co">        A class for loading and plotting EEG data</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="co">        eeg_file : str, path to the .set file</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="co">        chan_file : str, path to the _channels.tsv file</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># load the eeg data</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._eeg <span class="op">=</span> sio.loadmat(eeg_file, appendmat<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> <span class="va">self</span>._eeg[<span class="st">'data'</span>]</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.srate <span class="op">=</span> <span class="va">self</span>._eeg[<span class="st">'srate'</span>][<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nchan <span class="op">=</span> <span class="va">self</span>.data.shape[<span class="dv">0</span>]</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nsamp <span class="op">=</span> <span class="va">self</span>.data.shape[<span class="dv">1</span>]</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dur <span class="op">=</span> <span class="va">self</span>.nsamp<span class="op">/</span><span class="va">self</span>.srate</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># load the channel info and integrate with locations</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>        chan_info <span class="op">=</span> <span class="va">self</span>._eeg[<span class="st">'chaninfo'</span>][<span class="dv">0</span>,<span class="dv">0</span>][<span class="dv">1</span>]</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>        chan_names <span class="op">=</span> [name.split()[<span class="dv">0</span>] <span class="cf">for</span> name <span class="kw">in</span> chan_info]</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>        chan_locs <span class="op">=</span> np.array([name.split()[<span class="dv">2</span>:] <span class="cf">for</span> name <span class="kw">in</span> chan_info], dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>        chan_info <span class="op">=</span> pd.DataFrame({<span class="st">'name'</span>: chan_names, </span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>                                    <span class="st">'ml'</span>: chan_locs[:,<span class="dv">0</span>], </span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>                                    <span class="st">'ap'</span>: chan_locs[:,<span class="dv">1</span>], </span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>                                    <span class="st">'dv'</span>: chan_locs[:,<span class="dv">2</span>]})</span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>        chans <span class="op">=</span> pd.read_csv(chan_file, sep<span class="op">=</span><span class="st">'</span><span class="ch">\t</span><span class="st">'</span>)</span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>        chans <span class="op">=</span> pd.merge(chans, chan_info, how<span class="op">=</span><span class="st">'left'</span>, on<span class="op">=</span><span class="st">'name'</span>)</span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>        chans.index.name <span class="op">=</span> <span class="st">'idx'</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.chans <span class="op">=</span> chans</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># get reference electrode position</span></span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>        ref_elec <span class="op">=</span> <span class="va">self</span>._eeg[<span class="st">'ref'</span>][<span class="dv">0</span>]</span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a>        near_ref_names <span class="op">=</span> [ref <span class="cf">for</span> ref <span class="kw">in</span> ref_elec.split(<span class="st">'_'</span>) <span class="cf">if</span> ref <span class="kw">in</span> chans[<span class="st">'name'</span>].tolist()]</span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>        near_ref_chans <span class="op">=</span> chans[chans[<span class="st">'name'</span>].isin(near_ref_names)]</span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a>        near_ref_coords <span class="op">=</span> near_ref_chans[[<span class="st">'ml'</span>, <span class="st">'ap'</span>, <span class="st">'dv'</span>]].to_numpy()</span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ref_coord <span class="op">=</span> np.mean(near_ref_coords, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_data(<span class="va">self</span>, chans<span class="op">=</span><span class="va">None</span>, start_t<span class="op">=</span><span class="dv">0</span>, dur_t<span class="op">=</span><span class="va">None</span>, scale<span class="op">=</span><span class="st">'absolute'</span>):</span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a><span class="co">        Extract EEG data from the EEG object</span></span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-45"><a href="#cb41-45" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb41-46"><a href="#cb41-46" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb41-47"><a href="#cb41-47" aria-hidden="true" tabindex="-1"></a><span class="co">        chans : list of str, the channels to extract</span></span>
<span id="cb41-48"><a href="#cb41-48" aria-hidden="true" tabindex="-1"></a><span class="co">        start_t : numeric array, the start times in seconds</span></span>
<span id="cb41-49"><a href="#cb41-49" aria-hidden="true" tabindex="-1"></a><span class="co">        dur_t : float, the duration in seconds</span></span>
<span id="cb41-50"><a href="#cb41-50" aria-hidden="true" tabindex="-1"></a><span class="co">        scale : str, 'absolute' or 'relative'</span></span>
<span id="cb41-51"><a href="#cb41-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-52"><a href="#cb41-52" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb41-53"><a href="#cb41-53" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb41-54"><a href="#cb41-54" aria-hidden="true" tabindex="-1"></a><span class="co">        data_epochs : 3d array, the eeg data</span></span>
<span id="cb41-55"><a href="#cb41-55" aria-hidden="true" tabindex="-1"></a><span class="co">        tpts : 1d array, the time vector</span></span>
<span id="cb41-56"><a href="#cb41-56" aria-hidden="true" tabindex="-1"></a><span class="co">        chans : list of str, the channels extracted</span></span>
<span id="cb41-57"><a href="#cb41-57" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb41-58"><a href="#cb41-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-59"><a href="#cb41-59" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ensure proper formatting of inputs</span></span>
<span id="cb41-60"><a href="#cb41-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> chans:</span>
<span id="cb41-61"><a href="#cb41-61" aria-hidden="true" tabindex="-1"></a>            chans <span class="op">=</span> <span class="va">self</span>.chans[<span class="st">'name'</span>]</span>
<span id="cb41-62"><a href="#cb41-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> chans <span class="op">==</span> <span class="st">'eeg'</span> <span class="kw">or</span> chans <span class="op">==</span> [<span class="st">'eeg'</span>]: <span class="co"># only extract eeg channels</span></span>
<span id="cb41-63"><a href="#cb41-63" aria-hidden="true" tabindex="-1"></a>            chans <span class="op">=</span> <span class="va">self</span>.chans[<span class="va">self</span>.chans[<span class="st">'type'</span>]<span class="op">==</span><span class="st">'EEG'</span>][<span class="st">'name'</span>].values</span>
<span id="cb41-64"><a href="#cb41-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">type</span>(chans) <span class="op">==</span> <span class="bu">str</span>:</span>
<span id="cb41-65"><a href="#cb41-65" aria-hidden="true" tabindex="-1"></a>            chans <span class="op">=</span> [chans]</span>
<span id="cb41-66"><a href="#cb41-66" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-67"><a href="#cb41-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> dur_t:</span>
<span id="cb41-68"><a href="#cb41-68" aria-hidden="true" tabindex="-1"></a>            dur_t <span class="op">=</span> <span class="va">self</span>.dur<span class="op">-</span>start_t</span>
<span id="cb41-69"><a href="#cb41-69" aria-hidden="true" tabindex="-1"></a>        start_t <span class="op">=</span> np.array(start_t)</span>
<span id="cb41-70"><a href="#cb41-70" aria-hidden="true" tabindex="-1"></a>        start_t <span class="op">=</span> start_t.ravel()</span>
<span id="cb41-71"><a href="#cb41-71" aria-hidden="true" tabindex="-1"></a>        epoch_num <span class="op">=</span> start_t.size</span>
<span id="cb41-72"><a href="#cb41-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-73"><a href="#cb41-73" aria-hidden="true" tabindex="-1"></a>        <span class="co"># convert times to indices</span></span>
<span id="cb41-74"><a href="#cb41-74" aria-hidden="true" tabindex="-1"></a>        start_idxs <span class="op">=</span> (start_t<span class="op">*</span><span class="va">self</span>.srate).astype(<span class="bu">int</span>)</span>
<span id="cb41-75"><a href="#cb41-75" aria-hidden="true" tabindex="-1"></a>        dur_idx <span class="op">=</span> (dur_t<span class="op">*</span><span class="va">self</span>.srate).astype(<span class="bu">int</span>)</span>
<span id="cb41-76"><a href="#cb41-76" aria-hidden="true" tabindex="-1"></a>        end_idxs <span class="op">=</span> start_idxs <span class="op">+</span> dur_idx</span>
<span id="cb41-77"><a href="#cb41-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-78"><a href="#cb41-78" aria-hidden="true" tabindex="-1"></a>        <span class="co"># get the channel indices</span></span>
<span id="cb41-79"><a href="#cb41-79" aria-hidden="true" tabindex="-1"></a>        chan_idxs <span class="op">=</span> [np.where(<span class="va">self</span>.chans[<span class="st">'name'</span>]<span class="op">==</span>sel_ch)[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">for</span> sel_ch <span class="kw">in</span> chans]</span>
<span id="cb41-80"><a href="#cb41-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-81"><a href="#cb41-81" aria-hidden="true" tabindex="-1"></a>        <span class="co"># extract the eeg data, one epoch at a time</span></span>
<span id="cb41-82"><a href="#cb41-82" aria-hidden="true" tabindex="-1"></a>        data_epochs <span class="op">=</span> np.zeros((dur_idx, <span class="bu">len</span>(chan_idxs), epoch_num)) <span class="co"># this also ensures changes to the data don't affect the original</span></span>
<span id="cb41-83"><a href="#cb41-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(epoch_num):</span>
<span id="cb41-84"><a href="#cb41-84" aria-hidden="true" tabindex="-1"></a>            data_epochs[:,:,i] <span class="op">=</span> <span class="va">self</span>.data[chan_idxs, start_idxs[i]:end_idxs[i]].T</span>
<span id="cb41-85"><a href="#cb41-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-86"><a href="#cb41-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># get the time vector</span></span>
<span id="cb41-87"><a href="#cb41-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> scale <span class="op">==</span> <span class="st">'absolute'</span>:</span>
<span id="cb41-88"><a href="#cb41-88" aria-hidden="true" tabindex="-1"></a>            tpts <span class="op">=</span> start_t <span class="op">+</span> np.arange(<span class="dv">0</span>, dur_idx)<span class="op">/</span><span class="va">self</span>.srate</span>
<span id="cb41-89"><a href="#cb41-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> scale <span class="op">==</span> <span class="st">'relative'</span>:</span>
<span id="cb41-90"><a href="#cb41-90" aria-hidden="true" tabindex="-1"></a>            tpts <span class="op">=</span> np.arange(<span class="dv">0</span>, dur_idx)<span class="op">/</span><span class="va">self</span>.srate</span>
<span id="cb41-91"><a href="#cb41-91" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-92"><a href="#cb41-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> data_epochs, tpts, chans</span>
<span id="cb41-93"><a href="#cb41-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-94"><a href="#cb41-94" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> plot_scalp(<span class="va">self</span>, ax<span class="op">=</span><span class="va">None</span>, colors<span class="op">=</span><span class="st">'b'</span>):</span>
<span id="cb41-95"><a href="#cb41-95" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb41-96"><a href="#cb41-96" aria-hidden="true" tabindex="-1"></a><span class="co">        Plot the channel locations on the scalp</span></span>
<span id="cb41-97"><a href="#cb41-97" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb41-98"><a href="#cb41-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-99"><a href="#cb41-99" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ensure proper formatting of inputs</span></span>
<span id="cb41-100"><a href="#cb41-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> ax:</span>
<span id="cb41-101"><a href="#cb41-101" aria-hidden="true" tabindex="-1"></a>            fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb41-102"><a href="#cb41-102" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-103"><a href="#cb41-103" aria-hidden="true" tabindex="-1"></a>        chans <span class="op">=</span> <span class="va">self</span>.chans[<span class="va">self</span>.chans[<span class="st">'type'</span>]<span class="op">==</span><span class="st">'EEG'</span>]</span>
<span id="cb41-104"><a href="#cb41-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-105"><a href="#cb41-105" aria-hidden="true" tabindex="-1"></a>        <span class="co"># plot the channel locations</span></span>
<span id="cb41-106"><a href="#cb41-106" aria-hidden="true" tabindex="-1"></a>        ax.scatter(chans[<span class="st">'ml'</span>], chans[<span class="st">'ap'</span>], c<span class="op">=</span>colors)</span>
<span id="cb41-107"><a href="#cb41-107" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ind, name <span class="kw">in</span> <span class="bu">enumerate</span>(chans[<span class="st">'name'</span>]):</span>
<span id="cb41-108"><a href="#cb41-108" aria-hidden="true" tabindex="-1"></a>            ax.text(chans[<span class="st">'ml'</span>][ind], chans[<span class="st">'ap'</span>][ind], name)</span>
<span id="cb41-109"><a href="#cb41-109" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-110"><a href="#cb41-110" aria-hidden="true" tabindex="-1"></a>        <span class="co"># plot the reference electrode</span></span>
<span id="cb41-111"><a href="#cb41-111" aria-hidden="true" tabindex="-1"></a>        ax.scatter(<span class="va">self</span>.ref_coord[<span class="dv">0</span>], <span class="va">self</span>.ref_coord[<span class="dv">1</span>], c<span class="op">=</span><span class="st">'k'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb41-112"><a href="#cb41-112" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-113"><a href="#cb41-113" aria-hidden="true" tabindex="-1"></a>        ax.set_xlabel(<span class="st">'Medial-lateral'</span>)</span>
<span id="cb41-114"><a href="#cb41-114" aria-hidden="true" tabindex="-1"></a>        ax.set_ylabel(<span class="st">'Anterior-posterior'</span>)</span>
<span id="cb41-115"><a href="#cb41-115" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="st">'Channel locations for </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(subj))</span>
<span id="cb41-116"><a href="#cb41-116" aria-hidden="true" tabindex="-1"></a>        ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb41-117"><a href="#cb41-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-118"><a href="#cb41-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ax</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s give this class a try. It should shorten all the code we did above.</p>
<div id="e6262d59" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get file paths</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>subj <span class="op">=</span> <span class="st">'sub-AB58'</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>chan_dir <span class="op">=</span> [<span class="st">'.'</span>, <span class="st">'data'</span>, <span class="st">'eeg'</span>, <span class="st">'ds003690'</span>, subj, <span class="st">'eeg'</span>, <span class="st">'</span><span class="sc">{}</span><span class="st">_task-passive_run-1_channels.tsv'</span>.<span class="bu">format</span>(subj)]</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>chan_file <span class="op">=</span> op.join(<span class="op">*</span>chan_dir) <span class="co"># use * to unpack the list</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>data_dir <span class="op">=</span> [<span class="st">'.'</span>, <span class="st">'data'</span>, <span class="st">'eeg'</span>, <span class="st">'ds003690'</span>, subj, <span class="st">'eeg'</span>, <span class="st">'</span><span class="sc">{}</span><span class="st">_task-passive_run-1_eeg.set'</span>.<span class="bu">format</span>(subj)]</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>eeg_file <span class="op">=</span> op.join(<span class="op">*</span>data_dir) <span class="co"># use * to unpack the list</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="co"># create an EEG object</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>eeg <span class="op">=</span> EEG(eeg_file, chan_file)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the scalp</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>eeg_chan_num <span class="op">=</span> np.<span class="bu">sum</span>(eeg.chans[<span class="st">'type'</span>]<span class="op">==</span><span class="st">'EEG'</span>)</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>scalp_ax <span class="op">=</span> eeg.plot_scalp(colors<span class="op">=</span><span class="bu">range</span>(eeg_chan_num))</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>plt.colorbar(scalp_ax.collections[<span class="dv">0</span>], ax<span class="op">=</span>scalp_ax, label<span class="op">=</span><span class="st">'Channel number'</span>)</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a><span class="co"># get the 2 channels of eeg data at 2 time points</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>eeg_epochs, tpts, chans <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>[<span class="st">'O1'</span>, <span class="st">'O2'</span>], start_t<span class="op">=</span>[<span class="dv">50</span>, <span class="dv">100</span>], dur_t<span class="op">=</span><span class="dv">2</span>, scale<span class="op">=</span><span class="st">'relative'</span>)</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the eeg data</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">4</span>))</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(tpts, eeg_epochs[:,<span class="dv">0</span>,:])</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">'Relative time (s)'</span>)</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(chans[<span class="dv">0</span>], subj))</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(tpts, eeg_epochs[:,<span class="dv">1</span>,:])</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'Relative time (s)'</span>)</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(chans[<span class="dv">1</span>], subj))</span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-27-output-1.png" width="462" height="449" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-27-output-2.png" width="950" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="time-series-statistics" class="level3">
<h3 class="anchored" data-anchor-id="time-series-statistics">Time series statistics</h3>
<p>Now that we can easily load in EEG data, let’s explore some of the statistics we use to summarize it. Since the EEG signal is a series of voltages sampled at evenly spaced time intervals, we will make use of the statistical measures used for time series data more generally. To start, we will reload the EEG epoch we started with using our new EEG data class.</p>
<div id="3bffed5f" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>eeg_data, eeg_t, eeg_chan <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>[<span class="st">'O1'</span>], start_t<span class="op">=</span><span class="dv">50</span>, dur_t<span class="op">=</span><span class="dv">2</span>, scale<span class="op">=</span><span class="st">'absolute'</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>eeg_data <span class="op">=</span> eeg_data.ravel() <span class="co"># ravel flattens the array</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="mean" class="level4">
<h4 class="anchored" data-anchor-id="mean">Mean</h4>
<p>Time series data is often considered to be the repeated sampling of an ongoing process. The values given off by that process will have a distribution, and if that distribution is normal then the two measures that characterize that distribution are its <em>mean</em> and <em>variance</em>.</p>
<p><span class="math display"> Mean = E[X] = \frac{1}{n}\sum_{t=1}^{n}X_{t} </span></p>
<p>To translate, the mean can be written as a function <span class="math inline">E[X]</span>, which stands for the <strong>E</strong>xpected value of <span class="math inline">X</span>. The expected value is equal to the sum (<span class="math inline">\sum</span>) from the first (<span class="math inline">t=1</span>) to the last (<span class="math inline">n</span>) value of each individual (<span class="math inline">t</span>) time point of <span class="math inline">X</span>, expressed as <span class="math inline">X_{t}</span>, divided by the number of time points (<span class="math inline">n</span>). The corresponding explicit code for this is:</p>
<div id="4c1133a3" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A method that explicitly expresses how to calculate the mean in base python</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mean(x):</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">sum</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n):</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sum</span> <span class="op">+=</span> x[t]</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span> <span class="op">/</span> n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Assuming our data has a normal distribution, the mean tells us which value is most likely to be expressed at any given moment. In the case of the EEG epoch we have above, this value is:</p>
<div id="da51d0a9" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>eeg_data_mean <span class="op">=</span> mean(eeg_data)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Mean of the EEG epoch: </span><span class="sc">{:.2f}</span><span class="st"> uV'</span>.<span class="bu">format</span>(eeg_data_mean))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Mean of the EEG epoch: -14701.82 uV</code></pre>
</div>
</div>
</section>
<section id="variance" class="level4">
<h4 class="anchored" data-anchor-id="variance">Variance</h4>
<p>Besides them mean, we also want a measure of the variability in the voltage around the mean. A measure frequently used is the <em>variance</em>. It is calculated as: <span class="math display"> Variance = Var[X] = E[(X-E[X])^2] = \frac{1}{n}\sum_{t=1}^{n}(X_{t}-E[X])^2 </span></p>
<p>The variance is the mean of the squared difference between the values in our time series and the mean value. We can cast this explicitly in code also:</p>
<div id="1835feb1" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A method that explicitly expresses how to calculate variance in base python</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> variance(x):</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">sum</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    e_x <span class="op">=</span> mean(x)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n):</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sum</span> <span class="op">+=</span> (x[t] <span class="op">-</span> e_x)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span> <span class="op">/</span> n</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>eeg_data_var <span class="op">=</span> variance(eeg_data)</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Variance of the EEG epoch: </span><span class="sc">{:.2f}</span><span class="st"> uV^2'</span>.<span class="bu">format</span>(eeg_data_var))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Variance of the EEG epoch: 71.67 uV^2</code></pre>
</div>
</div>
</section>
<section id="standard-deviation" class="level4">
<h4 class="anchored" data-anchor-id="standard-deviation">Standard deviation</h4>
<p>Notice that the variance is in units of uV<sup>2</sup>. Since we analyze EEG in units of uV, it is difficult for us to directly interpret the variance. Instead, we can take its square root, giving us a measure the of the variability in the EEG signal that is in units of uV. The square root of the variance is the familiar <em>standard deviation</em>. If we measure the standard deviation of our EEG epoch, we get:</p>
<div id="32143cb0" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A method that explicitly expresses how to calculate standard deviation in base python</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sd(x):</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> variance(x)<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>eeg_data_sd <span class="op">=</span> sd(eeg_data)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Standard deviation of the EEG epoch: </span><span class="sc">{:.2f}</span><span class="st"> uV'</span>.<span class="bu">format</span>(eeg_data_sd))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Standard deviation of the EEG epoch: 8.47 uV</code></pre>
</div>
</div>
</section>
<section id="the-normal-distribution" class="level4">
<h4 class="anchored" data-anchor-id="the-normal-distribution">The normal distribution</h4>
<p>If a signal is normally distributed, then all we need to approximate its distribution is its expected value and variance. The normal distribution is captured by the curve: <span class="math display"> p(X_{i}) = \frac{1}{\sqrt{Var[X]2\pi}}exp\left[{-\frac{(X_{i}-E[X])^{2}}{2Var[X]}}\right]</span></p>
<p>Translating this into code we get:</p>
<div id="e1438e16" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A method that explicitly expresses how to calculate the probability of a </span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co"># data point being observed given a normal distribution</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> normal(x, x_i):</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    e_x <span class="op">=</span> mean(x)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    v_x <span class="op">=</span> variance(x)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    scale_factor <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>((<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>v_x)<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>))) <span class="co"># sets the height of the curve</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    shape_factor <span class="op">=</span> np.exp(<span class="op">-</span>((x_i <span class="op">-</span> e_x)<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>v_x)) <span class="co"># sets the width of the curve</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> scale_factor <span class="op">*</span> shape_factor</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2de06fc9" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>samp_vals <span class="op">=</span> np.linspace(np.<span class="bu">min</span>(eeg_data), np.<span class="bu">max</span>(eeg_data), <span class="dv">50</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>norm_vals <span class="op">=</span> [normal(eeg_data, samp) <span class="cf">for</span> samp <span class="kw">in</span> samp_vals]</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>ax.plot(samp_vals, norm_vals, c<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Probability density'</span>)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Predicted distribution of voltages for </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(sel_chan, subj))</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-34-output-1.png" width="662" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>How does this predicted distribution compare with the actual distribution of values? To answer this question, we need to plot the probability of a particular value occurring in our EEG epoch. We could try plotting the values as hatch marks at the bottom of the graph, and see if their density is highest near the center of the normal curve.</p>
<div id="120d4537" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the normal distribution, and short vertical lines on the x-axis where each data point from eeg_epoch is</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>ax.plot(samp_vals, norm_vals, c<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Probability density'</span>)</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Predicted distribution of voltages for </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(sel_chan, subj))</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>ax.vlines(eeg_data, <span class="dv">0</span>, <span class="fl">0.005</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-35-output-1.png" width="662" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>In this graph, each voltage sample is represented as a single vertical line (which we will refer to as hatch marks), with its position on the voltage axis determined by its value. It appears that they are clustered near the center of the normal distribution. Indeed, the density of hatch marks there is so high that they fuse together into a single black mass. It would be better if we could estimate the density of hatch marks along the voltage axis. To do this, we will calculate a <em>histogram</em>, which divides the voltage axis into a series of <em>bins</em> and measures the number of data points in each bin. These counts are then scaled by the number of data points, <span class="math inline">n</span>, and the length of the bin to give us probability density. Here is how we can code this:</p>
<div id="1aa98fde" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A method that explicitly expresses how to calculate a probability density histogram</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> histogram(x, bin_num):</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    x_min <span class="op">=</span> <span class="bu">min</span>(x)</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    x_max <span class="op">=</span> <span class="bu">max</span>(x)</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    bin_width <span class="op">=</span> (x_max <span class="op">-</span> x_min)<span class="op">/</span>bin_num</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    bin_edges <span class="op">=</span> x_min <span class="op">+</span> bin_width <span class="op">*</span> <span class="bu">range</span>(bin_num<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    bin_centers <span class="op">=</span> np.zeros(bin_num)</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>    bin_heights <span class="op">=</span> np.zeros(bin_num)</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    scale_factor <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(n<span class="op">*</span>bin_width)</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,bin_num):</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>        bin_count <span class="op">=</span> <span class="bu">len</span>(x[(x <span class="op">&gt;=</span> bin_edges[i]) <span class="op">&amp;</span> (x <span class="op">&lt;</span> bin_edges[i<span class="op">+</span><span class="dv">1</span>])])</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>        bin_heights[i] <span class="op">=</span> (scale_factor <span class="op">*</span> bin_count)</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>        bin_centers[i] <span class="op">=</span> (bin_edges[i] <span class="op">+</span> bin_width<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> bin_centers, bin_heights</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="a2d91089" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate the empirical distribution of the EEG data</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>bin_centers, bin_heights <span class="op">=</span> histogram(eeg_data, <span class="dv">20</span>)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the empirical distribution</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>bin_width <span class="op">=</span> bin_centers[<span class="dv">1</span>]<span class="op">-</span>bin_centers[<span class="dv">0</span>]</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>ax.bar(bin_centers, bin_heights, width<span class="op">=</span>bin_width, align<span class="op">=</span><span class="st">'center'</span>)</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>ax.plot(samp_vals, norm_vals, c<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>ax.vlines(eeg_data, <span class="dv">0</span>, <span class="fl">0.005</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Probability density'</span>)</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Histogram of voltages for </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(sel_chan, subj))</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-37-output-1.png" width="662" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Now we have a much better sense of the distribution of the EEG values. We can see that they generally follow the contours of the normal distribution, but not perfectly. There is an overabundance of low values, and fewer values around the mean. Looking back at the plot of our EEG snippet, it appears that the signal wanders, with periods of low values and high values. This might explain the deviation from a normal distribution when we have only sampled for a short length of time, 2 seconds.</p>
<p>Adjacent samples in the time series tend to have similar values. This is unlike most other data you may have worked with, such as tabular data, where each data point is sampled independently from the others. In the case of time series data, adjacent samples will be necessarily related to each other since they were obtained near the same time. Is there a way to quantify this?</p>
</section>
<section id="autocovariance" class="level4">
<h4 class="anchored" data-anchor-id="autocovariance">Autocovariance</h4>
<p>What we want is a measure of the similarity between samples in our time series as a function of how apart they are in time. If adjacent samples tend to both be above or below the mean, we want our measure to be high, and we want to it to be near zero when they are unrelated. The autocovariance function behaves this way.</p>
<p><span class="math display"> ACov[\tau] = E[(X_{t}-E[X])(X_{t+\tau}-E[X])]</span></p>
<p>Put in words, we create a new time series, <span class="math inline">(X_{t}-E[X])(X_{t+\tau}-E[X])</span>, by multiplying a mean subtracted version of our time series by itself at some fixed time lag (<span class="math inline">\tau</span>), and then measure the mean value of this new time series. We do this for a range of lags. In code, this looks like:</p>
<div id="259e73f1" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A method that explicitly expresses how to calculate the autocovariance of a signal</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> autocovariance(x, lag):</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    e_x <span class="op">=</span> mean(x)</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">sum</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n<span class="op">-</span>lag):</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sum</span> <span class="op">+=</span> (x[t] <span class="op">-</span> e_x)<span class="op">*</span>(x[t<span class="op">+</span>lag] <span class="op">-</span> e_x)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span> <span class="op">/</span> (n<span class="op">-</span>lag)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="bc64514f" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate autocovariance for lags 0 to 20</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>lags <span class="op">=</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">50</span>)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>autocov <span class="op">=</span> [autocovariance(eeg_data, lag) <span class="cf">for</span> lag <span class="kw">in</span> lags]</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Since our sample rate is 500 Hz, we can convert the lags to time in seconds</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>lags_sec <span class="op">=</span> np.array(lags)<span class="op">/</span>srate</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot autocovariance as stem plot</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>ax.stem(lags_sec, autocov)</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Lag (sec)'</span>)</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Autocovariance (uV$^2$)'</span>)</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Autocovariance of voltages for </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(sel_chan, subj))</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-39-output-1.png" width="660" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>A few things stand out here. First, when the lag is 0 sec, the value of the autocovariance is the same as the variance we estimated earlier (71.7 uV<sup>2</sup>). This is because for the zero lag case, the equation for autocovariance and variance are exactly the same. Second, as we increase the lag the autocovariance decreases, indicating that samples farther apart in time are less similar to each other. Lastly, you can see some periodic ripples riding on the autocovariance at 20, 40, 60, and 80 ms. It is no coincidence that these are evenly spaces 20 ms apart. They are due to contamination by power line noise, which is at a frequency of 50 Hz in Europe, where this data was obtained. We will discuss this further in the next section.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Using built-in Numpy functions
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that the Numpy package has methods for calculating the mean (<code>np.mean</code>), variance (<code>np.var</code>), and standard deviation (<code>np.std</code>). These offer far greater control over how these operations are carried out with multidimensional arrays, and so you should use them. As an example, let’s rewrite the autocovariance function using Numpy methods, since Numpy does not have one built-in.</p>
<div id="2d1baed7" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A method that calculates the autocovariance of a signal using numpy methods</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> autocovariance(x, lag):</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    e_x <span class="op">=</span> np.mean(x)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>((x[<span class="dv">0</span>:n<span class="op">-</span>lag] <span class="op">-</span> e_x)<span class="op">*</span>(x[lag:n] <span class="op">-</span> e_x)) <span class="op">/</span> (n<span class="op">-</span>lag)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="artifacts-and-noise" class="level3">
<h3 class="anchored" data-anchor-id="artifacts-and-noise">Artifacts and noise</h3>
<p>Environmental electrical noise that is homogeneous across the head will be eliminated by the proper referencing described above. However, there are other sources of electrical interference that are not homogeneous across this head. This is especially true for those arising from the head itself. Recall from our discussion of extracellular potentials that voltage falls off with distance. This means that electrodes close to a location on the head producing non-neural electrical signals will record very different signals.</p>
<p>These sources are sometimes referred to as noise, and other times as artifacts. Common sources are skin potentials, eye movements and blinks (electrooculogram), muscle movements (electromyogram), and power line interference. Thus, we can conceive of the EEG as a sum of neural and non-neural sources:</p>
<p><span class="math display"> EEG = Neural + EOG + ACPower + EMG + Scalp </span></p>
<p>Let’s consider each of these non-neural sources, and how to eliminate them.</p>
<section id="skin-potentials" class="level4">
<h4 class="anchored" data-anchor-id="skin-potentials">Skin potentials</h4>
<p>The skin is a conductive medium with its own voltage potential between its inside and outside. This voltage changes with the skin’s conductivity. Often this occurs slowly over time by the opening and closing of sweat glands and the hydration of the skin by the conductive gel underneath the EEG electrode. It can also change suddenly when the electrode is moved.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/501_Structure_of_the_skin.jpg" class="img-fluid figure-img"></p>
<figcaption>skin anatomy</figcaption>
</figure>
</div>
<p>To see how much the skin potential can drift, take a look at a single EEG recording channel for the entire recording duration.</p>
<div id="35ce6bc8" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load entire O1 channel EEG recording</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>eeg_data_full, eeg_t_full, eeg_chan_full <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>[<span class="st">'O1'</span>])</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>eeg_data_full <span class="op">=</span> eeg_data_full.ravel()</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="co"># plot full eeg recording</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>ax.plot(eeg_t_full, eeg_data_full)</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(eeg_chan_full[<span class="dv">0</span>], subj))</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-41-output-1.png" width="662" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The level of the EEG varies greatly over the 4 minutes of the recording. It’s offset starts around -14,650 uV, and drifts down to -14,850 uV, spanning a range of 200 uV. This far exceeds the standard deviation of the signal, which we calculated over a short segment above at ~8.5 uV.</p>
<p>This is only on a single electrode. How heterogeneous are these offsets and drifts across electrodes?</p>
<div id="f4a51199" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load all eeg data</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>eeg_data_full, eeg_t_full, eeg_chan_full <span class="op">=</span> eeg.get_data(chans<span class="op">=</span><span class="st">'eeg'</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co"># get mean voltage from each channel</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>eeg_mean <span class="op">=</span> np.mean(eeg_data_full, axis<span class="op">=</span><span class="dv">0</span>).ravel()</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the mean voltage for each channel on the scalp</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>ax.hist(eeg_mean)</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Mean voltage (uV)'</span>)</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Channel count'</span>)</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Mean voltage for each channel from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(subj))</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Minimum mean voltage: </span><span class="sc">{:.2f}</span><span class="st"> uV'</span>.<span class="bu">format</span>(np.<span class="bu">min</span>(eeg_mean)))</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Maximum mean voltage: </span><span class="sc">{:.2f}</span><span class="st"> uV'</span>.<span class="bu">format</span>(np.<span class="bu">max</span>(eeg_mean)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Minimum mean voltage: -22535.51 uV
Maximum mean voltage: 8960.47 uV</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-42-output-2.png" width="661" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>There is a wide range of mean voltages across the channels, from -22.5 mV to 8.9 mV. How do they change with time? We saw that site O1 drifted towards more negative voltages, but was that also the case for the other channels? Let’s look at a few channels spread across the scalp.</p>
<div id="d0020870" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>drift_chans <span class="op">=</span> [<span class="st">'F1'</span>, <span class="st">'C1'</span>, <span class="st">'P1'</span>, <span class="st">'O1'</span>]</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="co"># get the eeg data for the drift channels</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>eeg_data_drift, eeg_t_drift, eeg_chan_drift <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>drift_chans)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the eeg data for the drift channels</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">4</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">5</span>,<span class="dv">7</span>))</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eeg_t_drift, eeg_data_drift[:,i,:])</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(eeg_chan_drift[i], subj))</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>fig.supxlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>fig.supylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-43-output-1.png" width="475" height="670" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Not all channels show the same slow drift in their potential. F1 drifted up, while C1, P1, and O1 drift down. C1 drifts down as a straight line, while P1 and O1 take wobbly paths. We want to eliminate these offsets. One way we could do this is to get a <em>running average</em> of the voltage and then subtract it from the original. This would eliminate the large offset and its slow drift, leaving only the fast fluctuations.</p>
<p>To calculate a running average, we will calculate the mean value of the time series over a fixed interval. We do this for each time point in the series, giving us a new time series with the same length as the original, but whose values are the local average. Mathematically, we can represent this as:</p>
<p><span class="math display"> Y_{t} = \frac{1}{2w+1}\sum_{\tau=-w}^{w}{X_{t+\tau}} \tag{1}</span></p>
<p>The size of the window we use is specified by <span class="math inline">w</span>. The larger <span class="math inline">w</span> we choose, the more data points we average together and moving average will reflect slower trends in the time series. At the limits, if <span class="math inline">w</span> is equal to 0, then we get the exact same time series back. This is useless for our purposes, because if we subtract it from the original time series we are left with nothing. On the other hand, as we increase <span class="math inline">w</span> the values in our moving average time series approach its mean value. This would capture the offset, but it would miss the trend. Thus, we want to set <span class="math inline">w</span>, which we will now refer to as our <em>window size</em>, to a value that is small enough to capture the drift in our time series, but not so small that it just recapitulates the time series and eliminates the signals we care about.</p>
<p>To explore these issues, we can code a moving average function with a parameter that controls window size.</p>
<div id="028f18ae" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A method that calculates a moving average</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> moving_average(x, w):</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.zeros(n)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n):</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> t <span class="op">&lt;</span> w: <span class="co"># if we are at the beginning of the signal</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>            y[t] <span class="op">=</span> np.mean(x[<span class="dv">0</span>:t<span class="op">+</span>w])</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> t <span class="op">&gt;</span> n<span class="op">-</span>w: <span class="co"># if we are at the end of the signal</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>            y[t] <span class="op">=</span> np.mean(x[t<span class="op">-</span>w:n])</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co"># if we are in the middle of the signal, same as equation 1</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>            y[t] <span class="op">=</span> np.mean(x[t<span class="op">-</span>w:t<span class="op">+</span>w])</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Before we apply this function to our data, a quick comment about how this code handles the beginning and end of the signal. Our window spans time points from <code>-w</code> to <code>w</code>, so if we are at the start of the signal then the samples from <code>-w</code> that would have gone into our average are not available, and likewise for the end of the signal with points on the <code>w</code> end. The approach taken here was to just take the mean of the points we did have. Another approach is to <em>pad</em> the edges of the signal, place a number <code>w</code> times at the beginning and end. If the number is 0, it is called <em>zero padding</em>. A problem with zero padding is that the mean will be distorted by those zeros early and late in the signal. Those distortions are referred to as <em>edge effects</em>. Alternative padding strategies can mitigate edge effects. For instance, instead of padding with zero you can use the value for the first or last sample, and pad with that. Or, you can reflect the signal at the edges.</p>
<div id="ca3f7b0f" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Try out the moving average function with different windows</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">125</span>, <span class="dv">2000</span>, <span class="dv">40000</span>, <span class="dv">132000</span>]</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">5</span>,figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">5</span>), sharey<span class="op">=</span><span class="st">'row'</span>)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    eeg_ma <span class="op">=</span> moving_average(eeg_data_full[:,<span class="dv">0</span>], w[i])</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    eeg_resid <span class="op">=</span> eeg_data_full[:,<span class="dv">0</span>].ravel() <span class="op">-</span> eeg_ma</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].plot(eeg_t_full, eeg_data_full[:,<span class="dv">0</span>],color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].plot(eeg_t_full, eeg_ma, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].set_title(<span class="st">'</span><span class="sc">{}</span><span class="st"> sec'</span>.<span class="bu">format</span>(<span class="dv">2</span><span class="op">*</span>w[i]<span class="op">/</span>eeg.srate))</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,i].plot(eeg_t_full, eeg_resid)</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>fig.supxlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>fig.supylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-45-output-1.png" width="1134" height="480" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The top row shows the original signal in black, with the moving average overlaid on top in red. The bottom row of graphs with blue lines is the difference between the original EEG signal and the moving average, referred to as the <em>residual</em>. The most obvious change, which holds for all the window sizes, is that the voltage offset is removed. Our residual signals are now centered on 0 uV. Looking at the red and black lines, it is apparent that as we lengthen the duration of the window, the moving average line becomes smoother. For short durations, it follows the EEG signal closely. At our shortest window, it follows the signal so closely that the resulting residual is much smaller compared with the longer windows. At the other end of the spectrum, our longest window size fails to remove slow trends in the EEG, since you can see that its residual still has slow drift. The 0.5 second and 8 second windows seems to have equivalent effects. Seeing the difference between them will require looking at the data on a shorter time scale.</p>
<div id="7cc24931" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> [<span class="dv">125</span>, <span class="dv">2000</span>]</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>t_start_idx <span class="op">=</span> <span class="dv">50</span><span class="op">*</span>eeg.srate</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>t_end_idx <span class="op">=</span> <span class="dv">55</span><span class="op">*</span>eeg.srate</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>t_idxs <span class="op">=</span> <span class="bu">range</span>(t_start_idx, t_end_idx)</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">2</span>,figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">5</span>), sharey<span class="op">=</span><span class="st">'row'</span>)</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    eeg_ma <span class="op">=</span> moving_average(eeg_data_full[:,<span class="dv">0</span>], w[i])</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    eeg_resid <span class="op">=</span> eeg_data_full[:,<span class="dv">0</span>].ravel() <span class="op">-</span> eeg_ma</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].plot(eeg_t_full[t_idxs], eeg_data_full[t_idxs,<span class="dv">0</span>],color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].plot(eeg_t_full[t_idxs], eeg_ma[t_idxs], color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].set_title(<span class="st">'</span><span class="sc">{}</span><span class="st"> sec'</span>.<span class="bu">format</span>(<span class="dv">2</span><span class="op">*</span>w[i]<span class="op">/</span>eeg.srate))</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,i].plot(eeg_t_full[t_idxs], eeg_resid[t_idxs])</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>fig.supxlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>fig.supylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-46-output-1.png" width="1134" height="480" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The half-second window seems to follow the EEG a bit too closely, while the 8 second window is more even. Given all this, the 8 second window looks the best.</p>
<p>We can now create a function that takes the <code>EEG</code> object and returns a version of it with the baseline subtracted.</p>
<div id="1c81ca47" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># a function to remove baseline drift</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> remove_baseline_drift(eeg, w<span class="op">=</span><span class="dv">8</span>):</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># eeg: an EEG object</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># w: window size in seconds</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># returns: an EEG object with baseline drift removed</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># convert window size to number of samples</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> <span class="bu">int</span>((w<span class="op">/</span><span class="dv">2</span>) <span class="op">*</span> eeg.srate)</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create convolution kernel</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> np.ones((<span class="dv">1</span>, <span class="dv">2</span><span class="op">*</span>w<span class="op">+</span><span class="dv">1</span>)) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>w<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># determine which channels are EEG</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    eeg_chans <span class="op">=</span> eeg.chans[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'EEG'</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># convolve kernel with EEG data using scipy.signal.convolve</span></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>    baseline <span class="op">=</span> ss.convolve(eeg.data[eeg_chans,:], kernel, mode<span class="op">=</span><span class="st">'same'</span>)</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># subtract baseline from EEG data</span></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>    eeg.data[eeg_chans,:] <span class="op">=</span> eeg.data[eeg_chans,:] <span class="op">-</span> baseline</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This function makes use of the <code>convolve</code> method found in the Scipy Signal package. The convolution operation is similar to the the moving average operation we created above. For the moving average, you can imagine that we are sliding a list of numbers (often called a <em>kernel</em>) that is as long as our window, and each has the value of <span class="math inline">1/(2w+1)</span>, across the EEG time series. At each time point in the time series, we multiply the values in that time window with the corresponding values in the kernel, and add them together. This gives us the average surround each time point. With convolution, instead of having all the values in the kernel have the same value, they can take on different values. We will make use of this later.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/Convolution_of_box_signal_with_itself2.gif" class="img-fluid figure-img"></p>
<figcaption>convolution</figcaption>
</figure>
</div>
<p>Let’s see how our baseline removal function performs.</p>
<div id="b09f7cfa" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># run slow drift removal</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>remove_baseline_drift(eeg)</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>example_chans <span class="op">=</span> [<span class="st">'F1'</span>, <span class="st">'C1'</span>, <span class="st">'P1'</span>, <span class="st">'O1'</span>]</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="co"># get the eeg data for the drift channels</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>eeg_data_drift, eeg_t_drift, eeg_chan_drift <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>example_chans)</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the eeg data for the drift channels</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">4</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">5</span>,<span class="dv">7</span>))</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eeg_t_drift, eeg_data_drift[:,i,:])</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(eeg_chan_drift[i], subj))</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>fig.supxlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>fig.supylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-48-output-1.png" width="475" height="670" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Uh oh, it appears that we have edge effects. At the beginning and end of the time series there are distortions. This is because the scipy convolve function zero-pads the time series. To mitigate this, we can change the padding. Instead of using zeros, we will just take the signal value at the edges.</p>
<div id="39ab255d" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># a function to remove baseline drift</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> remove_baseline_drift(eeg, w<span class="op">=</span><span class="dv">8</span>):</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># eeg: an EEG object</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># w: window size in seconds</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># returns: an EEG object with baseline drift removed</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># convert window size to number of samples</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> <span class="bu">int</span>((w<span class="op">/</span><span class="dv">2</span>) <span class="op">*</span> eeg.srate)</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create convolution kernel</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> np.ones((<span class="dv">1</span>, <span class="dv">2</span><span class="op">*</span>w<span class="op">+</span><span class="dv">1</span>)) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>w<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># determine which channels are EEG</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>    eeg_chans <span class="op">=</span> eeg.chans[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'EEG'</span></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># pad data with edge values &lt;-- HERE IS A CHANGE</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>    data_pad <span class="op">=</span> np.pad(eeg.data[eeg_chans,:], ((<span class="dv">0</span>,<span class="dv">0</span>), (w,w)), <span class="st">'edge'</span>)</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># convolve kernel with EEG data using scipy.signal.convolve</span></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (mode='valid' to keep output the same size as the input after padding) &lt;-- HERE IS A CHANGE</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>    baseline <span class="op">=</span> ss.convolve(data_pad, kernel, mode<span class="op">=</span><span class="st">'valid'</span>)</span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># subtract baseline from EEG data</span></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>    eeg.data[eeg_chans,:] <span class="op">=</span> eeg.data[eeg_chans,:] <span class="op">-</span> baseline</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To check if our fix worked, we will load a fresh version of the <code>eeg</code> object and try baseline removal again.</p>
<div id="7fbb36db" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create an EEG object</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>eeg <span class="op">=</span> EEG(eeg_file, chan_file)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="co"># remove baseline drift</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>remove_baseline_drift(eeg)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a><span class="co"># plot EEG with baseline drift removed</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>drift_chans <span class="op">=</span> [<span class="st">'F1'</span>, <span class="st">'C1'</span>, <span class="st">'P1'</span>, <span class="st">'O1'</span>]</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="co"># get the eeg data for the drift channels</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>eeg_data_drift, eeg_t_drift, eeg_chan_drift <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>example_chans)</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the eeg data for the drift channels</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">4</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">5</span>,<span class="dv">7</span>))</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eeg_t_drift, eeg_data_drift[:,i,:])</span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(eeg_chan_drift[i], subj))</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>fig.supxlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>fig.supylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-50-output-1.png" width="475" height="670" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Much better! We can now cross one source of noise off our list: <span class="math display"> EEG = Neural + EOG + ACPower + EMG \cancel{\ +\ Scalp} </span></p>
</section>
<section id="muscle-artifacts" class="level4">
<h4 class="anchored" data-anchor-id="muscle-artifacts">Muscle artifacts</h4>
<p>Your muscles are electrochemical devices that put out their own potentials, called <em>electromyographic</em> activity, abbreviated EMG. When a muscle is depolarized, it can produce a strong Na<sup>+</sup> and Ca<sup>2+</sup> action potential. Muscle contraction is driven by a barrage of these fast potentials, which can be picked up on electrodes many centimeters away. EMG will be most associated with mouth, forehead, and neck movements. This activity will be very fast relative to the slower activities detected in EEG. You can see EMG in the EEG signals shown above around 200 sec into the recording. Here is a closeup:</p>
<div id="063115e4" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the eeg data centered on a burst of EMG</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">4</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">5</span>,<span class="dv">7</span>))</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eeg_t_drift, eeg_data_drift[:,i,:])</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(eeg_chan_drift[i], subj))</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>    ax[i].set_xlim([<span class="dv">200</span>, <span class="dv">205</span>])</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>fig.supxlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>fig.supylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-51-output-1.png" width="475" height="670" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>To remove EMG, you can use a <em>filter</em>. We already covered a type of filter, the moving averages we calculated were effectively filters that kept the slow baseline shift. The same concept can be applied to remove EMG, which is at a higher frequency than the neural sources of the EEG that we care about. To provide grater control over the frequencies we want to remove, we will now turn to the filter functions provided in the Scipy Signals package.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/Filter-Diagram.jpg" class="img-fluid figure-img"></p>
<figcaption>filter diagram</figcaption>
</figure>
</div>
<p>A filter is defined by its type, cutoff frequency, and order.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/filter_types.png" class="img-fluid figure-img"></p>
<figcaption>filter types</figcaption>
</figure>
</div>
<p>The two major types we will concern ourselves with are <em>low pass</em> and <em>high pass</em>. Low pass filters allow slow changes in the signal to be passed through, like the moving average we used above to extract the slow drift signal. High pass filters do the opposite, they block the slow portion of the signal and instead allow the faster components through.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/low-pass-filter.png" class="img-fluid figure-img"></p>
<figcaption>filter properties</figcaption>
</figure>
</div>
<p>When we talk about slow and fast parts of the signal, we formally define those by their <em>frequency</em>. We will discuss these in far greater detail in later lectures, but for now you can think of frequency as representing the time scale of the signal. Formally, frequency is measured in events per second, Hertz. If a signal fluctuates 10 times per second, then we say it has a frequency of 10 Hz. The <em>cutoff frequency</em> is the frequency that below which signals are allowed pass for a low pass filter, or which signals are above which are allowed to pass for high pass filters. EMG power tends to be present above 60 Hz. The range of frequencies that are relatively unattenuated by the filter are referred to as the <em>pass band</em>.</p>
<p>Filters are generally not perfect, they do not block all signals on one side of the cutoff frequency, and allow all signals on the other side to pass unimpeded. To sharpen the cutoff transition, you can increase the <em>order</em> of the filter. However, this can introduce distortions into the signal, which usually inclines us to keep the order low.</p>
<p>Let’s create a low pass filter using the Scipy Signals package to remove the EMG component from our EEG signal.</p>
<div id="7905b1fe" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a low pass filter</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>b, a <span class="op">=</span> ss.butter(<span class="dv">4</span>, <span class="dv">60</span>, <span class="st">'low'</span>, fs<span class="op">=</span>eeg.srate) <span class="co"># create the filter coefficients</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function <code>butter</code> takes parameters that specify the properties of the filter, and returns the filter’s <em>coefficients</em>, <code>b</code> and <code>a</code>. The <code>b</code> term is analogous to the kernel we used in when calculating the moving average, while the <code>a</code> term is a kernel applied to the previous values of the filter’s output. If you generate a filter just with the <code>b</code> values (you can use <code>scipy.signal.firwin</code>), it is referred to as a <em>finite impulse response</em> (FIR) filter. If your filter has <code>b</code> and <code>a</code> kernels, then it is an <em>infinite impulse response</em> (IIR) filter. IIR filters have dramatically improved performance over FIR. But how do we evaluate the performance of a filter? An easy way to visualize this is to pass signals with different frequencies through the filter, and measure how much they are attenuated. Signals in the filter’s pass band should have little or no attenuation, while those outside it should be strongly suppressed.</p>
<p>The Scipy Signals package provides a function, <code>freqz</code> for doing this. Here is how to use it:</p>
<div id="6a4cf530" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="co"># compute the frequency response of the filter</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>w, h <span class="op">=</span> ss.freqz(b, a, fs<span class="op">=</span>eeg.srate)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>freq_resp <span class="op">=</span> <span class="dv">20</span><span class="op">*</span>np.log10(<span class="bu">abs</span>(h)) <span class="co"># convert to dB</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the frequency response in Hz</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>plt.plot(w, freq_resp)</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Butterworth filter frequency response'</span>)</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Frequency [Hz]'</span>)</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Amplitude [dB]'</span>)</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, <span class="dv">100</span>)</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="dv">25</span>, <span class="dv">5</span>)</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>plt.margins(<span class="dv">0</span>, <span class="fl">0.1</span>)</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>plt.grid(which<span class="op">=</span><span class="st">'both'</span>, axis<span class="op">=</span><span class="st">'both'</span>)</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">60</span>, color<span class="op">=</span><span class="st">'green'</span>) <span class="co"># cutoff frequency</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-53-output-1.png" width="608" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The cutoff frequency is marked with a green vertical line. To see how the filter works, lets pass a type of periodic signal called a sine wave through it. As we increase the frequency of the sine wave above the cutoff, we should see a dramatic decrease in its amplitude.</p>
<div id="9dbf23df" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>sin_freqs <span class="op">=</span> [<span class="dv">20</span>, <span class="dv">45</span>, <span class="dv">60</span>, <span class="dv">80</span>]</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>t_vals <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="fl">0.1</span>, <span class="fl">0.002</span>)</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plot original sine wave and its filtered version</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, freq <span class="kw">in</span> <span class="bu">enumerate</span>(sin_freqs):</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>    sin_orig <span class="op">=</span> np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>freq<span class="op">*</span>t_vals)</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    sin_filt <span class="op">=</span> ss.lfilter(b, a, sin_orig) <span class="co"># filter the signal</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(t_vals, sin_orig)</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(t_vals, sin_filt)</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="st">'freq = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(freq))</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>    ax[i].set_xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>    ax[i].set_ylabel(<span class="st">'Amplitude'</span>)</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-54-output-1.png" width="951" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The blue lines are the original sine waves, while the orange is the filtered version. As we increase the frequency of the sine wave, the filter attenuates it more. At the cutoff frequency, 60 Hz, it is attenuated to approximately 70% of its original amplitude, which is known as the -3dB cutoff. You can also see that the filtered signal is shifted. This is known as <em>phase distortion</em> and varies as a function of the frequency. Using the output from the <code>freqz</code> function, we can visualize how this distortion varies systematically with frequency.</p>
<div id="6f0ac762" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the phase distortion of the butterworth filter</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>plt.plot(w, np.angle(h)) <span class="co"># h is an array of complex numbers, where the phase-shift is the angle of the complex number</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Butterworth filter phase response'</span>)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Frequency [Hz]'</span>)</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Phase [radians]'</span>)</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, <span class="dv">100</span>)</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>plt.margins(<span class="dv">0</span>, <span class="fl">0.1</span>)</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">60</span>, color<span class="op">=</span><span class="st">'green'</span>) <span class="co"># cutoff frequency</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-55-output-1.png" width="600" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Edge effects are also present. At the start of the signal the shape of the filtered version is different from its shape later on, which appears to stabilize. This is due to the zero-padding done by the function <code>lfilter</code>, similar to the issue we ran into with our moving average calculation. Also noteworthy is the lack of an edge effect at the end of the signal. This is because the filter kernels are slid across the signal from left to right, and the kernels are not symmetric. Unlike the moving average kernel, which was applied to data points before and after each sample in a time series, <code>b</code> and <code>a</code> are only applied to the samples before. This is also why we have a phase distortion, because the filter is applied in one direction, from past values to the present. When doing a BCI that has data streaming in real-time, this is the only option (you cannot know what brain activity will look like in the future). However, an offline BCI does not have this limitation. To slide the filter both direction, forwards, and then backwards, we can use <code>scipy.signals.filtfilt</code>.</p>
<div id="518ec75c" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot original sine wave and its filtered version</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, freq <span class="kw">in</span> <span class="bu">enumerate</span>(sin_freqs):</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    sin_orig <span class="op">=</span> np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>freq<span class="op">*</span>t_vals)</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    sin_filt <span class="op">=</span> ss.filtfilt(b, a, sin_orig) <span class="co"># filter the signal forwards, and then backwards</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(t_vals, sin_orig)</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(t_vals, sin_filt)</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="st">'freq = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(freq))</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>    ax[i].set_xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>    ax[i].set_ylabel(<span class="st">'Amplitude'</span>)</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-56-output-1.png" width="951" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Using <code>filtfilt</code> improved things! It virtually eliminated the phase distortion. Frequency selectivity is also better now, with frequencies outside the pass band showing greater reduction in amplitude. This is because the filter is applied twice, effectively increasing its order. On the other hand, there is still an edge effect, but it is most prominent for frequencies outside the pass band.</p>
<p>Now that we are familiar with filters, we can apply them to removing EMG activity from the EEG signal. Let’s create a function similar to our <code>remove_baseline_drift</code> to do that.</p>
<div id="f4a11376" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co"># function to remove EMG artifacts from EEG data</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> remove_emg(eeg, cut_freq<span class="op">=</span><span class="dv">60</span>):</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># eeg: EEG data</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># cut_freq: cutoff frequency</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create a bandpass filter</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    b, a <span class="op">=</span> ss.butter(<span class="dv">4</span>, cut_freq, <span class="st">'low'</span>, fs<span class="op">=</span>eeg.srate)</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># determine which channels are EEG</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>    eeg_chans <span class="op">=</span> eeg.chans[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'EEG'</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># apply the filter to the data</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>    eeg.data[eeg_chans,:] <span class="op">=</span> ss.filtfilt(b, a, eeg.data[eeg_chans,:], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a><span class="co"># remove the emg from the data</span></span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>remove_emg(eeg)</span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a><span class="co"># pull out the sample channels again, centered on the time period </span></span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a><span class="co"># with the EMG artifact</span></span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a>eeg_data_emg, eeg_t_emg, eeg_chan_emg <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>example_chans, start_t<span class="op">=</span><span class="dv">200</span>, dur_t<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a><span class="co"># overlay the EMG filtered over the original visualize the section of </span></span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a><span class="co"># data that previously had an EMG artifact</span></span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">4</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">5</span>,<span class="dv">7</span>))</span>
<span id="cb76-25"><a href="#cb76-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb76-26"><a href="#cb76-26" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eeg_t_drift, eeg_data_drift[:,i,:])</span>
<span id="cb76-27"><a href="#cb76-27" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eeg_t_emg, eeg_data_emg[:,i,:])</span>
<span id="cb76-28"><a href="#cb76-28" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(eeg_chan_drift[i], subj))</span>
<span id="cb76-29"><a href="#cb76-29" aria-hidden="true" tabindex="-1"></a>    ax[i].set_xlim([<span class="dv">200</span>, <span class="dv">205</span>])</span>
<span id="cb76-30"><a href="#cb76-30" aria-hidden="true" tabindex="-1"></a>fig.supxlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb76-31"><a href="#cb76-31" aria-hidden="true" tabindex="-1"></a>fig.supylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb76-32"><a href="#cb76-32" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-57-output-1.png" width="475" height="670" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The orange signal with the EMG filter applied shows less EMG activity than before, a good sign. Some still remains, but this will be hard to eliminate without distorting the EEG signal or removing frequencies that we care about.</p>
<p><span class="math display"> EEG = Neural + EOG + ACPower \cancel{\ + EMG \ }\cancel{\ +\ Scalp} </span></p>
</section>
<section id="ac-power-line-noise" class="level4">
<h4 class="anchored" data-anchor-id="ac-power-line-noise">AC power line noise</h4>
<p>Even with excellent referencing, AC power interference can still leak into recordings and must be dealt with. In the US this is at 60 Hz, while in Europe, where this recording comes from, it is at 50 Hz. What does this signal look like? In our recording, channel FCz exhibited prominent 50 Hz AC noise.</p>
<div id="af9f2d9f" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get an EEG epoch with a lot of AC noise</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>eeg_data_ac, eeg_t_ac, eeg_chan_ac <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>[<span class="st">'FCz'</span>], start_t<span class="op">=</span><span class="dv">200</span>, dur_t<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the data</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>ax.plot(eeg_t_ac, eeg_data_ac.squeeze())</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (sec)'</span>)</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'EEG data at FCz'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre><code>Text(0.5, 1.0, 'EEG data at FCz')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-58-output-2.png" width="810" height="376" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Notice that the EEG oscillates at a regular rate, and that this masks the underlying irregular EEG activity that presumably arises from neural sources.</p>
<p>There are two filtering strategies we can use. The easiest way to eliminate it is to filter out any signals in the EEG that are at or above the frequency of the AC signal. For this we could apply the same filtering strategy we used for the EMG. But, keep in mind that if we set the cutoff frequency of the filter to the AC frequency, it will only attenuate it moderately. To further suppress the AC signal, we would need to set the cutoff to a lower frequency, perhaps 30 Hz in the case of our 50 Hz AC noise. This runs the risk of eliminating activity we care about, but let’s try it anyway.</p>
<div id="ce39db1d" class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load EEG signal with AC noise</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>eeg_data_ac, eeg_t_ac, eeg_chan_ac <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>[<span class="st">'FCz'</span>], start_t<span class="op">=</span><span class="dv">200</span>, dur_t<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="co"># create low pass filter</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>b_lp,a_lp <span class="op">=</span> ss.butter(<span class="dv">4</span>, <span class="dv">30</span>, <span class="st">'low'</span>, fs<span class="op">=</span>eeg.srate)</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a><span class="co"># apply filter</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>eeg_data_lp <span class="op">=</span> ss.filtfilt(b_lp,a_lp,eeg_data_ac, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a><span class="co"># plot</span></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">3</span>))</span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>plt.plot(eeg_t_ac, eeg_data_ac.squeeze(), label<span class="op">=</span><span class="st">'raw'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>plt.plot(eeg_t_ac, eeg_data_lp.squeeze(), label<span class="op">=</span><span class="st">'low pass'</span>)</span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (sec)'</span>)</span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-59-output-1.png" width="810" height="282" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>That certainly reduces the 50 Hz noise. However, the signal has now lost much of its sharpness because the cutoff for the low pass filter was set to 30 Hz. We are throwing out a lot of signal that may arise from neural sources.</p>
<p>The second filtering option is to use a <em>notch filter</em>. It suppresses frequencies centered on a specific value, such as 50 Hz, while allowing others to pass, whether they be higher or lower, to pass through unimpeded. This is useful for AC noise because its frequency is specific to just one value.</p>
<p>A notch filter is specified by two parameters. Its center frequency, <span class="math inline">\omega_0</span> (<code>w0</code> in the code below), sets frequency at which the maximum attenuation occurs. The depth of this attenuation and its spread to adjacent frequencies is determined by its Q (for quality) factor. A higher Q will decrease the attenuation at <span class="math inline">\omega_0</span> and its spread to adjacent frequencies. Thus, there is a trade off. The filter can strongly attenuate the frequency you want to reject, but at the cost of impacting other nearby frequencies. If you want to minimize that impact, you can lower Q, but at the cost of attenuating the center frequency less. Let’s use the <code>iirnotch</code> function to create a notch filter at 50 Hz with a moderate Q.</p>
<div id="8efe60d6" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create notch filter coeffients</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>b_nc, a_nc <span class="op">=</span> ss.iirnotch(w0<span class="op">=</span><span class="dv">50</span>, Q<span class="op">=</span><span class="dv">15</span>, fs<span class="op">=</span>eeg.srate)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="co"># apply filter</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>eeg_data_nc <span class="op">=</span> ss.filtfilt(b_nc,a_nc,eeg_data_ac, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a><span class="co"># plot</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">3</span>))</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>plt.plot(eeg_t_ac, eeg_data_ac.squeeze(),  label<span class="op">=</span><span class="st">'raw'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>plt.plot(eeg_t_ac, eeg_data_lp.squeeze(),  label<span class="op">=</span><span class="st">'low pass'</span>)</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>plt.plot(eeg_t_ac, eeg_data_nc.squeeze(),  label<span class="op">=</span><span class="st">'notch'</span>)</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (sec)'</span>)</span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-60-output-1.png" width="810" height="282" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The notch filter allows higher frequencies to get through, while still attenuating the 50 Hz noise. It is good to see a difference in filter performance by eye on the signals we want to process, but a more systematic approach would be to characterize the frequency response properties of the filters.</p>
<div id="311e1058" class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate frequency responses of filters</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>w_lp, h_lp <span class="op">=</span> ss.freqz(b_lp, a_lp, fs<span class="op">=</span>eeg.srate)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>w_nc, h_nc <span class="op">=</span> ss.freqz(b_nc, a_nc, fs<span class="op">=</span>eeg.srate)</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="co"># plot frequency response of filter</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>))</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(w_lp, <span class="dv">20</span> <span class="op">*</span> np.log10(<span class="bu">abs</span>(h_lp)), label<span class="op">=</span><span class="st">'low pass'</span>)</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(w_nc, <span class="dv">20</span> <span class="op">*</span> np.log10(<span class="bu">abs</span>(h_nc)), label<span class="op">=</span><span class="st">'notch'</span>)</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].axvline(<span class="dv">50</span>, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'50 Hz'</span>)</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlim(<span class="dv">0</span>,<span class="dv">100</span>)</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylim(<span class="op">-</span><span class="dv">50</span>,<span class="dv">5</span>)</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">'Frequency (Hz)'</span>)</span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'Gain (dB)'</span>)</span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">'Frequency Response'</span>)</span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend()</span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the phase response of filter</span></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(w_lp, np.angle(h_lp))</span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(w_nc, np.angle(h_nc))</span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].axvline(<span class="dv">50</span>, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlim(<span class="dv">0</span>,<span class="dv">100</span>)</span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylim(<span class="op">-</span>np.pi,np.pi)</span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'Frequency (Hz)'</span>)</span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">'Phase (rad)'</span>)</span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">'Phase Response'</span>)</span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-61-output-1.png" width="950" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>At the AC frequency, the attenuation from both the low pass and notch are equivalent. However, the drawback of the low pass is apparent due to it attenuating signals beyond the AC frequency. Moreover, the low pass filter introduces substantial phase distortion in the pass band, which contains EEG signals we care about. This is not a problem if we are analyzing the data offline and can run the filter forwards and backwards with <code>filtfilt</code>, but would be a serious issue this was for a real-time BCI application that can only run in the forward direction.</p>
<p>Given that, let’s create a function for removing AC noise from the EEG using a notch filter.</p>
<div id="67bb8e01" class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co"># function to remove AC noise from EEG data</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> remove_ac(eeg, ac_freq<span class="op">=</span><span class="dv">60</span>): </span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># eeg: EEG data</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ac_freq: frequency of the AC noise (default: 60 Hz because we're in the US)</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create a bandpass filter</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>    b, a <span class="op">=</span> ss.iirnotch(ac_freq, <span class="dv">15</span>, fs<span class="op">=</span>eeg.srate)</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># determine which channels are EEG</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>    eeg_chans <span class="op">=</span> eeg.chans[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'EEG'</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># apply the filter to the data</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    eeg.data[eeg_chans,:] <span class="op">=</span> ss.filtfilt(b, a, eeg.data[eeg_chans,:], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a><span class="co"># remove the emg from the data</span></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>remove_ac(eeg, <span class="dv">50</span>)</span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a><span class="co"># pull out the sample channels again, centered on the time period </span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a><span class="co"># with the EMG artifact</span></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>eeg_data_ac, eeg_t_ac, eeg_chan_ac <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>example_chans, start_t<span class="op">=</span><span class="dv">10</span>, dur_t<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a><span class="co"># overlay the AC filtered over the original signal</span></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">4</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">5</span>,<span class="dv">7</span>))</span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eeg_t_drift, eeg_data_drift[:,i,:], alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eeg_t_ac, eeg_data_ac[:,i,:])</span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="st">'Channel </span><span class="sc">{}</span><span class="st"> from </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(eeg_chan_drift[i], subj))</span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a>    ax[i].set_xlim([<span class="dv">10</span>,<span class="dv">11</span>])</span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a>    ax[i].set_ylim([<span class="op">-</span><span class="dv">25</span>,<span class="dv">25</span>])</span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a>fig.supxlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true" tabindex="-1"></a>fig.supylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-62-output-1.png" width="475" height="670" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Our AC filter seems to work really well.</p>
<p><span class="math display"> EEG = Neural + EOG \cancel{\ + \ ACPower} \cancel{\ + EMG \ }\cancel{\ +\ Scalp} </span></p>
</section>
<section id="eye-blinks-and-movement-artifacts" class="level4">
<h4 class="anchored" data-anchor-id="eye-blinks-and-movement-artifacts">Eye blinks and movement artifacts</h4>
<p>Your eyeball is polarized, with large potential difference between the cornea and retina. This potential, referred to as the <a href="https://pubmed.ncbi.nlm.nih.gov/31277871"><em>electrooculogram</em></a>(EOG)affects electrodes on the scalp, with those at frontal sites just above the eyes, such as F or Fp, picking it up most strongly. So long as the eye remains motionless, this just causes a constant offset in the voltage at an EEG electrode. But eyes move, a lot, especially when subjects are engaged in the kinds of activities we want to relate back to the brain. Your eyes constantly dart around, called <em>saccading</em>, between different spots in your field of view. When the eye moves or blinks, the voltages at your EEG sites change. Since each EEG electrode will pick this up differently, one cannot just rely on referencing to eliminate. The signal on the reference electrode will look different from that on other electrodes. The simplest way to deal with these is to measure the eye movements directly by placing electrodes adjacent to the subject’s eyes, and then exclude periods when eye movements were present from subsequent analysis. More sophisticated approaches (e.g.&nbsp;independent component analysis) can isolate and remove the contribution of eye blinks to the EEG, allowing one to analyze periods where they occurred. These are beyond the purview of this course.</p>
<p>To detect eye blinks, investigators place recording electrodes near the subject’s eyes. This gives a relatively pure measure of the EOG. Our recording has two channels for this, VEO and HEO.</p>
<div id="769d1721" class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get EOG signal</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>eog_data, eog_t, eog_chans <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>[<span class="st">'VEO'</span>, <span class="st">'HEO'</span>])</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plot EOG signal</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>plt.plot(eog_t, eog_data.squeeze(), label<span class="op">=</span>eog_chans)</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'EOG (uV)'</span>)</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'EOG signals'</span>)</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-63-output-1.png" width="610" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Well, looks like we have drifting baselines in our EOG signals. If you look closely at the HEO trace, you can see little occasional ticks. These reflect eye blinks. They are not so apparent on the VEO trace. Remove the baseline from the HEO signal and zoom in on one of those eye blink events. (This recording is a little funny because eye blinks are usually best detected on the VEO channel positioned above the eye. It might be a mistake in how the channels were labeled or connected by the experimenter.)</p>
<div id="10a49de1" class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>heo <span class="op">=</span> eog_data[:, <span class="dv">1</span>, <span class="dv">0</span>].copy()</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="co"># moving average window</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>window <span class="op">=</span> <span class="dv">1</span> <span class="co"># seconds</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>heo <span class="op">=</span> heo<span class="op">-</span>moving_average(heo, eeg.srate<span class="op">*</span>window)</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>plt.plot(eog_t, heo)</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="dv">112</span>, <span class="dv">118</span>))</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'HEO (uV)'</span>)</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Eyeblink events'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="63">
<pre><code>Text(0.5, 1.0, 'Eyeblink events')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-64-output-2.png" width="617" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Each eyeblink is associated with a large voltage deflection (&gt;150 uV) that, at least near the eye, which dwarfs the EEG potentials we record from the scalp (~20 uV). To see how the EEG channels pick up the EOG, we will plot the same time period from some example EEG channels, which range from the front to the back of the scalp.</p>
<div id="42ea6678" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>eeg_data, eeg_t, eeg_chans <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>example_chans, start_t <span class="op">=</span> <span class="dv">112</span>, dur_t<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot each eeg data channel in a separate axis with the heo signal underneath</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="bu">len</span>(example_chans), <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">10</span>), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, chan <span class="kw">in</span> <span class="bu">enumerate</span>(example_chans):</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eog_t, heo, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'EOG'</span>)</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(eeg_t, eeg_data[:, i], label<span class="op">=</span><span class="st">'EEG'</span>)</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(chan)</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>    ax[i].set_xlim([eeg_t[<span class="dv">0</span>], eeg_t[<span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    ax[i].set_ylim([<span class="op">-</span><span class="dv">200</span>, <span class="dv">200</span>])</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend()</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>fig.supylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>fig.supxlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-65-output-1.png" width="475" height="955" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The EOG artifact is readily apparent on the frontal site, F1, which is closest to the eye. Its influence fades at more posterior sites (towards the back of the head), but it can still have an impact. This can become especially problematic when we want to analyze brain activity during the presentation of visual stimuli. Often we blink or move our eyes involuntarily during the presentation of visual stimuli, so we need a way to deal with this.</p>
<p>One approach is to discern a relationship between the EOG and EEG signals, and then use that relationship to predict how the EEG will be affected by EOG. Using this, one can subtract that predicted signal from the EEG, and hopefully completely excise the EOG’s influence. This is doable, but is tricky to do well and we will not consider it further (but to see how, check out <a href="https://pubmed.ncbi.nlm.nih.gov/6187540/">this</a>).</p>
<p>The simplest approach is to detect the eye blink event from the EOG recording and block out that period from subsequent analysis. For this, we need to detect peaks in the EOG signal that exceed a threshold. Scipy signals offers a useful function called <code>findpeaks</code> that does just that. It has a variety of arguments that allow you to tailor exactly how to detect peaks in a signal. The ones we are most concerned with are:</p>
<ul>
<li><code>height</code>: which specifies the minimum value a peak can have</li>
<li><code>distance</code>: the minimum distance allowed between two peaks</li>
</ul>
<p>Notice that our EOG signal is negative-going, so we will have to negative the EOG signal we pass to <code>findpeaks</code> to ensure that it works properly. Given the example trace above, it appears that a height of 100 uV and a distance of 0.5 seconds should work.</p>
<div id="7433e9e9" class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>blink_h <span class="op">=</span> <span class="dv">100</span> <span class="co"># minimum height of the blink peak in uV</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>blink_d <span class="op">=</span> <span class="fl">0.5</span><span class="op">*</span>eeg.srate <span class="co"># minimum time between blinks in samples</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the blinks using findpeaks from the scipy.signal package</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>blink_idx, blink_props <span class="op">=</span> ss.find_peaks(<span class="op">-</span>heo, height<span class="op">=</span>blink_h, distance<span class="op">=</span>blink_d)</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="co"># get the time for each blink peak</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>blink_times <span class="op">=</span> blink_idx <span class="op">/</span> eeg.srate</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a><span class="co"># get the peak height for each blink</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>blink_heights <span class="op">=</span> <span class="op">-</span>blink_props[<span class="st">'peak_heights'</span>]</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the blink peaks on top of the HEO signal</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">4</span>))</span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>ax.plot(eog_t, heo)</span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>ax.scatter(blink_times, blink_heights, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'HEO (uV)'</span>)</span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Detected blink peaks'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<pre><code>Text(0.5, 1.0, 'Detected blink peaks')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-66-output-2.png" width="976" height="376" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The detection algorithm seems to be working pretty well. The only time where there may be problems is around 110 seconds, where a small peak is missed and a bunch of blinks have clustered close together, with one possibly evading detection. Let’s look closer:</p>
<div id="f0aa8fde" class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Replot the figure above, but zoomed in on the potentially problematic region</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>plt.figure(fig)</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">108</span>,<span class="dv">118</span>)</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-67-output-1.png" width="989" height="376" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Fortunately, it appears that our detection algorithm worked great during the cluster of eye blinks between 114 and 117 seconds. However, it did miss the small (partial?) blink at 110 seconds. To detect that, we would need to lower our threshold. Lets give that a try.</p>
<div id="38897c1c" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>blink_h <span class="op">=</span> <span class="dv">30</span> <span class="co"># minimum height of the blink peak in uV</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the blinks using findpeaks from the scipy.signal package</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>blink_idx, blink_props <span class="op">=</span> ss.find_peaks(<span class="op">-</span>heo, height<span class="op">=</span>blink_h, distance<span class="op">=</span>blink_d)</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="co"># get the time for each blink peak</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>blink_times <span class="op">=</span> blink_idx <span class="op">/</span> eeg.srate</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a><span class="co"># get the peak height for each blink</span></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>blink_heights <span class="op">=</span> <span class="op">-</span>blink_props[<span class="st">'peak_heights'</span>]</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the blink peaks on top of the HEO signal</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">4</span>))</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a>ax.plot(eog_t, heo)</span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a>ax.scatter(blink_times, blink_heights, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'HEO (uV)'</span>)</span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Detected blink peaks'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="67">
<pre><code>Text(0.5, 1.0, 'Detected blink peaks')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-68-output-2.png" width="976" height="376" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Much better. It has even picked up on a cluster of weak blinks around 200 seconds that escaped my attention before. Just to be careful, let’s check those out and make sure they are detected properly and nothing has been missed.</p>
<div id="76b42252" class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Replot the figure above, but zoomed in on the potentially problematic region</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>plt.figure(fig)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">190</span>,<span class="dv">210</span>)</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-69-output-1.png" width="995" height="376" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Uh oh, what looked like blinks when zoomed out turns out to be another kind of artifact, EMG. We have two options for dealing with this. One would be to just set the threshold high enough not to detect those EMG bursts. However, doing so might make us lose the weak eye blink earlier in the recording. Alternatively, we could filter out the EMG like we did for the EEG data prior to running the peak detection. Thus, to create a function for eye blink detection we need to pool together the following step:</p>
<ol type="1">
<li>Get the EOG signal</li>
<li>Invert the EOG signal</li>
<li>Remove the baseline drift</li>
<li>Remove the EMG</li>
<li>Find peaks</li>
</ol>
<p>Steps 3 and 4 are both filtering operations, with removal of baseline drift a high pass filter with a very low frequency cutoff (~1 Hz), and EMG removal a low pass filter with a cutoff around 50 Hz. Instead of splitting these into two separate filtering steps, we can implement them as one filter, called a <em>band pass</em> filter. A band pass filter has a low and high frequency cutoff, and allows signals to pass between those. Let’s design our <code>detect_blinks</code> function with one of those.</p>
<div id="4b72d1af" class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> detect_blinks(eeg, eog_chan<span class="op">=</span><span class="st">'HEO'</span>, threshold<span class="op">=</span><span class="dv">40</span>, ibi<span class="op">=</span><span class="fl">0.5</span>):</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Detect blinks in the EEG signal.</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="co">    eeg : our EEG object</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a><span class="co">    eog_chan : str</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a><span class="co">        The name of the EOG channel. Defaults to 'HEO'.</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a><span class="co">    threshold : float</span></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a><span class="co">        The threshold for detecting blinks. Defaults to 40.</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a><span class="co">    ibi : float</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a><span class="co">        The minimum inter-blink interval (in seconds). Defaults to 0.5.</span></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a><span class="co">    blink_times : array of floats</span></span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a><span class="co">        The times of the blinks in seconds.</span></span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a><span class="co">    blink_heights : array of floats</span></span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a><span class="co">        The height of the blinks.   </span></span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Format inputs</span></span>
<span id="cb93-23"><a href="#cb93-23" aria-hidden="true" tabindex="-1"></a>    ibi <span class="op">=</span> ibi <span class="op">*</span> eeg.srate</span>
<span id="cb93-24"><a href="#cb93-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-25"><a href="#cb93-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the EOG channel</span></span>
<span id="cb93-26"><a href="#cb93-26" aria-hidden="true" tabindex="-1"></a>    eog_data, eog_t, _ <span class="op">=</span> eeg.get_data(chans<span class="op">=</span>eog_chan)</span>
<span id="cb93-27"><a href="#cb93-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-28"><a href="#cb93-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Format EOG data for peak finding</span></span>
<span id="cb93-29"><a href="#cb93-29" aria-hidden="true" tabindex="-1"></a>    eog_data <span class="op">=</span> <span class="op">-</span>eog_data.squeeze()</span>
<span id="cb93-30"><a href="#cb93-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-31"><a href="#cb93-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filter drifting baseline and EMG out of the EOG data</span></span>
<span id="cb93-32"><a href="#cb93-32" aria-hidden="true" tabindex="-1"></a>    b, a <span class="op">=</span> ss.butter(<span class="dv">2</span>, [<span class="dv">1</span>, <span class="dv">50</span>], <span class="st">'bandpass'</span>, fs<span class="op">=</span>eeg.srate)</span>
<span id="cb93-33"><a href="#cb93-33" aria-hidden="true" tabindex="-1"></a>    eog_data <span class="op">=</span> ss.filtfilt(b, a, eog_data)</span>
<span id="cb93-34"><a href="#cb93-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-35"><a href="#cb93-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the blinks</span></span>
<span id="cb93-36"><a href="#cb93-36" aria-hidden="true" tabindex="-1"></a>    blink_times, blink_props <span class="op">=</span> ss.find_peaks(eog_data, height<span class="op">=</span>threshold, distance<span class="op">=</span>ibi)</span>
<span id="cb93-37"><a href="#cb93-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-38"><a href="#cb93-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert blink_times to seconds</span></span>
<span id="cb93-39"><a href="#cb93-39" aria-hidden="true" tabindex="-1"></a>    blink_times <span class="op">=</span> eog_t[blink_times]</span>
<span id="cb93-40"><a href="#cb93-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-41"><a href="#cb93-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get the blink heights</span></span>
<span id="cb93-42"><a href="#cb93-42" aria-hidden="true" tabindex="-1"></a>    blink_heights <span class="op">=</span> <span class="op">-</span>blink_props[<span class="st">'peak_heights'</span>]</span>
<span id="cb93-43"><a href="#cb93-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-44"><a href="#cb93-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> blink_times, blink_heights</span>
<span id="cb93-45"><a href="#cb93-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-46"><a href="#cb93-46" aria-hidden="true" tabindex="-1"></a>blink_times, blink_heights <span class="op">=</span> detect_blinks(eeg)</span>
<span id="cb93-47"><a href="#cb93-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-48"><a href="#cb93-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the blink peaks on top of the HEO signal</span></span>
<span id="cb93-49"><a href="#cb93-49" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">4</span>))</span>
<span id="cb93-50"><a href="#cb93-50" aria-hidden="true" tabindex="-1"></a>ax.plot(eog_t, heo)</span>
<span id="cb93-51"><a href="#cb93-51" aria-hidden="true" tabindex="-1"></a>ax.scatter(blink_times, blink_heights, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb93-52"><a href="#cb93-52" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb93-53"><a href="#cb93-53" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'HEO (uV)'</span>)</span>
<span id="cb93-54"><a href="#cb93-54" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Detected blink peaks'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="69">
<pre><code>Text(0.5, 1.0, 'Detected blink peaks')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-70-output-2.png" width="976" height="376" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Including the EMG filter, as part of the band pass filter, fixed the problem of detecting EMG. Now we know what times to exclude in our subsequent analyses to ensure that our data is not contaminated by EOG artifacts.</p>
<p><span class="math display"> EEG = Neural \cancel{\ +\ EOG} \cancel{\ + \ ACPower} \cancel{\ + EMG \ }\cancel{\ +\ Scalp} </span></p>
</section>
</section>
<section id="a-simple-model-of-the-eeg-signal" class="level3">
<h3 class="anchored" data-anchor-id="a-simple-model-of-the-eeg-signal">A simple model of the EEG signal</h3>
<p>We have just covered a variety of neural and non-neural sources for our EEG signal. Once we eliminated the noise and artifactual contributions to the EEG, we are left with just the neural source. This can be thought of as an equation:</p>
<p><span class="math display"> Neural = Neural_{evoked} + Neural_{spon} </span></p>
<p><span class="math inline">Neural_{evoked}</span> is the neural activity that is time-locked to stimuli or behavioral events. <span class="math inline">Neural_{spon}</span> is spontaneous brain activity that is not time-locked to events, or is ongoing.</p>
<p>For the rest of the lesson, we will go over how to eliminate or account for each these. In particular, we are interested in extracting <span class="math inline">Neural_{evoked}</span> component.</p>
</section>
</section>
<section id="evoked-response-potentials" class="level2">
<h2 class="anchored" data-anchor-id="evoked-response-potentials">Evoked response potentials</h2>
<p>Events, whether stimuli or actions, are associated with a chain of activation throughout the nervous system. For instance, stimuli activate peripheral sensory receptors (such as the retina), producing a cascade of neural activation moves towards the cortex. Upon reaching the cortex, it is conveyed for further processing to determine the features of the stimulus and its relevance. This chain of activity can be picked up by EEG electrodes as a stimulus <em>evoked response</em>, which has a stereotypical time course that, to some extent, is related to the properties of the stimulus and its meaning. Evoked responses were first demonstrated shortly after Berger discovered the EEG, and have remained a mainstay of understanding brain function.</p>
<p>Evoked responses can be characterized using the <em>event-related potential technique</em>. A subject with EEG electrodes is seated comfortably and performs a task that features the repeated presentation of stimuli. Sometimes the task is passive, in which case the subject simply attends to the stimuli but does not respond. Other times the task can be active and demands a response, such as a button press, that depends on the presentation of the stimulus or one of its features. Each stimulus presentation is referred to as <em>trial</em>. The periods between trials, the <em>inter-trial interval</em> (ITIs), are usually several seconds long. This allows for the observable effects of the stimulus on brain state to fade and not contaminate the next stimulus presentation.</p>
<p>Once the task is over, the researcher extracts the <em>epochs</em> of the EEG surrounding each time an event occurs. They then average these with respect to time to generate the mean <em>event-related potential</em> (ERP). Often an ERP is comprised of a series of peaks and troughs, which are generally referred to as components. While it is tempting to ascribe each component to a different underlying neural process, this is not necessarily the case. Since the focus of this course is on decoding the electrical activity of the brain, we can side step this complication. The question we are faced with here is whether there is a pattern to the EEG that indicates the presence or identity of an event, not how the brain generated it.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/p300.png" class="img-fluid figure-img"></p>
<figcaption>Example ERPs</figcaption>
</figure>
</div>
<p>Above is an example of a <a href="https://www.science.org/doi/10.1126/science.150.3700.1187">classic ERP</a>. Two types of trials were presented to subjects. During CERTAIN trials, a ‘cueing’ stimulus indicated whether the ‘test’ stimulus that followed 3-5 seconds later would be a sound or a light. For UNCERTAIN trials, the cueing stimulus did not predict the test stimulus. This figure shows the ERP to the same sound test stimulus, with those presented on certain trials as a solid line, while the dashed line is for the test stimulus on uncertain trials. Each graph shows the ERPs for different subjects. The ERPs are slightly different between subjects, but in general we can see an quick initial negative peak around 100 ms, and a positive going longer peak at 300 ms. Note that the voltage scale is flipped, with positive facing down and negative facing up.</p>
<p>Those peaks are named according to a nomenclature used by ERP researchers. In general, the names start with a ‘P’ (positive) or ‘N’ (negative), that indicate the sign of the peak. This is followed by a number, either denoting the order of the peak (1 = first, 2 = second, etc), or its latency from the event time in milliseconds. For our example, the initial negative peak is known as a N100, which is evoked by an auditory stimulus. The next major component is the P300, and is strengthened when a stimulus is unexpected. As you can see in the figure above, the ERP was substantially more positive for the UNCERTAIN condition.</p>
<section id="calculating-erps" class="level3">
<h3 class="anchored" data-anchor-id="calculating-erps">Calculating ERPs</h3>
<p>For the data set we loaded, there was an auditory stimulus presented. To calculate the ERP, we need to know the times it occurred. These are stored in a file with the name ‘*_events.tsv’. We already covered how to read .tsv files when we loaded the channel information. Let’s do the same for the events data.</p>
<div id="35e64d00" class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load the a *_channels.tsv file</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>subj <span class="op">=</span> <span class="st">'sub-AB58'</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>evt_dir <span class="op">=</span> [<span class="st">'.'</span>, <span class="st">'data'</span>, <span class="st">'eeg'</span>, <span class="st">'ds003690'</span>, subj, <span class="st">'eeg'</span>, <span class="st">'</span><span class="sc">{}</span><span class="st">_task-passive_run-1_events.tsv'</span>.<span class="bu">format</span>(subj)]</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>evt_file <span class="op">=</span> op.join(<span class="op">*</span>evt_dir) <span class="co"># use * to unpack the list</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>events <span class="op">=</span> pd.read_csv(evt_file, sep<span class="op">=</span><span class="st">'</span><span class="ch">\t</span><span class="st">'</span>)</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(events)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      onset  duration  sample trial_type  response_time  stim_file  value
0    12.084       NaN    6042        cue            NaN        NaN      1
1    19.384       NaN    9692        cue            NaN        NaN      1
2    26.398       NaN   13199        cue            NaN        NaN      1
3    34.224       NaN   17112        cue            NaN        NaN      1
4    42.258       NaN   21129        cue            NaN        NaN      1
5    50.148       NaN   25074        cue            NaN        NaN      1
6    59.184       NaN   29592        cue            NaN        NaN      1
7    66.008       NaN   33004        cue            NaN        NaN      1
8    74.248       NaN   37124        cue            NaN        NaN      1
9    81.408       NaN   40704        cue            NaN        NaN      1
10   89.604       NaN   44802        cue            NaN        NaN      1
11   97.628       NaN   48814        cue            NaN        NaN      1
12  106.708       NaN   53354        cue            NaN        NaN      1
13  114.678       NaN   57339        cue            NaN        NaN      1
14  122.868       NaN   61434        cue            NaN        NaN      1
15  130.924       NaN   65462        cue            NaN        NaN      1
16  138.024       NaN   69012        cue            NaN        NaN      1
17  147.120       NaN   73560        cue            NaN        NaN      1
18  154.494       NaN   77247        cue            NaN        NaN      1
19  161.784       NaN   80892        cue            NaN        NaN      1
20  170.020       NaN   85010        cue            NaN        NaN      1
21  177.394       NaN   88697        cue            NaN        NaN      1
22  185.760       NaN   92880        cue            NaN        NaN      1
23  193.554       NaN   96777        cue            NaN        NaN      1
24  200.530       NaN  100265        cue            NaN        NaN      1
25  209.654       NaN  104827        cue            NaN        NaN      1
26  218.660       NaN  109330        cue            NaN        NaN      1
27  227.440       NaN  113720        cue            NaN        NaN      1
28  234.904       NaN  117452        cue            NaN        NaN      1
29  242.270       NaN  121135        cue            NaN        NaN      1
30  259.322       NaN  129661   task end            NaN        NaN     10</code></pre>
</div>
</div>
<p>There are two columns we care about here. The ‘onset’ column gives the time when a stimulus was presented. These are the times we need to determine which epochs we want to record from. The other is ‘trial_type’, which indicates the type of stimulus given. For this data set, subjects were exposed to the same stimulus 30 times. The final event, ‘task end’, is just the end of the session.</p>
<p>It is the cue evoked ERP we want to calculate, so let’s pull out their times.</p>
<div id="f69d455b" class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>cue_times <span class="op">=</span> events[<span class="st">'onset'</span>][events[<span class="st">'trial_type'</span>] <span class="op">==</span> <span class="st">'cue'</span>].values</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The README file for this data set does not specify the time between cue stimuli, so let’s calculate that. This will tell us what the maximum epoch duration we can use to avoid having two stimuli in one epoch.</p>
<div id="e48cbfd4" class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate iternval between cue times</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>cue_iti <span class="op">=</span> np.diff(cue_times)</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot histogram of cue_iti</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>plt.hist(cue_iti, bins<span class="op">=</span>np.linspace(<span class="dv">0</span>, <span class="dv">12</span>, <span class="dv">24</span>))</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Count'</span>)</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Distribution of cue inter-trial intervals'</span>)</span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-73-output-1.png" width="576" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The ITIs range from 7 to 9 seconds, so we have nothing to worry about since our ERP will probably last no longer than 0.5 seconds. For our cue epochs, we will set the time windows to start 100 ms before the cue till 500 ms after.</p>
<p>Now that we have a cue window decided, we have to check whether any eye blinks overlap with our cue epochs. For those that do, we must remove them from analysis. Since blinks can last a couple hundred milliseconds, we will block out any epochs where a blink happened within 1 second of the stimulus.</p>
<div id="55a39c29" class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>excl_period <span class="op">=</span> <span class="fl">0.6</span> <span class="co"># exclusion period in seconds</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> remove_blink_epochs(epoch_times, blink_times, excl_period<span class="op">=</span>excl_period):</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Removes epochs from cue_times that are within excl_period of a blink.</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a><span class="co">    epoch_times : 1d array</span></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Epoch times in seconds.</span></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a><span class="co">    blink_times : 1d array</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Blink times in seconds.</span></span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a><span class="co">    excl_period : float</span></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Exclusion period in seconds.</span></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a><span class="co">    valid_epoch_times : 1d array</span></span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a><span class="co">        Epoch times that are not within excl_period of a blink.</span></span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a><span class="co">    percent_valid : float</span></span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a><span class="co">        Percentage of epochs that are valid.</span></span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a>    valid_epoch_times <span class="op">=</span> []</span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> time <span class="kw">in</span> epoch_times:</span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># gets us the times of blink relative to cue onset</span></span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true" tabindex="-1"></a>        rel_blink_times <span class="op">=</span> blink_times <span class="op">-</span> time </span>
<span id="cb99-26"><a href="#cb99-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-27"><a href="#cb99-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># if none of the blinks are within the exclusion period, keep the epoch</span></span>
<span id="cb99-28"><a href="#cb99-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> np.<span class="bu">any</span>(np.<span class="bu">abs</span>(rel_blink_times) <span class="op">&lt;</span> excl_period):</span>
<span id="cb99-29"><a href="#cb99-29" aria-hidden="true" tabindex="-1"></a>            valid_epoch_times.append(time)</span>
<span id="cb99-30"><a href="#cb99-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb99-31"><a href="#cb99-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(valid_epoch_times), <span class="bu">len</span>(valid_epoch_times)<span class="op">/</span><span class="bu">len</span>(epoch_times)<span class="op">*</span><span class="dv">100</span></span>
<span id="cb99-32"><a href="#cb99-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-33"><a href="#cb99-33" aria-hidden="true" tabindex="-1"></a>valid_cue_times, valid_percent <span class="op">=</span> remove_blink_epochs(cue_times, blink_times, excl_period)</span>
<span id="cb99-34"><a href="#cb99-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-35"><a href="#cb99-35" aria-hidden="true" tabindex="-1"></a><span class="co"># print the percentage of epochs we kept</span></span>
<span id="cb99-36"><a href="#cb99-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'There were </span><span class="sc">{}</span><span class="st"> blink free epochs'</span>.<span class="bu">format</span>(<span class="bu">len</span>(valid_cue_times)))</span>
<span id="cb99-37"><a href="#cb99-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Kept </span><span class="sc">{:.2f}</span><span class="st"> of epochs'</span>.<span class="bu">format</span>(valid_percent))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>There were 25 blink free epochs
Kept 83.33 of epochs</code></pre>
</div>
</div>
<p>We lose just under 20% of our cues because of blinks, which is substantial but not so much that it would seriously impact our averaging. We can use the <code>get_data</code> method of our EEG class to load the EEG at all sites during the blink-free cue presentations.</p>
<div id="ad587705" class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="co"># window settings</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>pre_window <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>post_window <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>epoch_dur <span class="op">=</span> pre_window <span class="op">+</span> post_window</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>epoch_starts <span class="op">=</span> valid_cue_times <span class="op">-</span> <span class="fl">0.1</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a><span class="co"># load epochs</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>cue_eeg <span class="op">=</span> eeg.get_data(chans<span class="op">=</span><span class="st">'eeg'</span>, start_t<span class="op">=</span>epoch_starts, </span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>                       dur_t<span class="op">=</span>epoch_dur, scale<span class="op">=</span><span class="st">'relative'</span>)</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a><span class="co"># split outputs</span></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>cue_data <span class="op">=</span> cue_eeg[<span class="dv">0</span>]</span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>cue_t <span class="op">=</span> cue_eeg[<span class="dv">1</span>]<span class="op">-</span>pre_window</span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a>cue_ch <span class="op">=</span> cue_eeg[<span class="dv">2</span>]</span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a><span class="co"># print the shape of each output</span></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'cue_data has the shape: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(cue_data.shape))</span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'cue_t has the shape: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(cue_t.shape))</span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'cue_ch has the shape: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(cue_ch.shape))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>cue_data has the shape: (300, 61, 25)
cue_t has the shape: (300,)
cue_ch has the shape: (61,)</code></pre>
</div>
</div>
<p>We set the time scale to ‘relative’ because we care about the time of the EEG signal only with respect to cue delivery. Since the <code>get_data</code> function returns times with respect to <code>start_t</code>, and we have that set 100 ms before the cue, we subtract those 100 ms from the relative time. This way, the cue onset is at time 0, and time points before the cue have negative values, while those after the cue have positive values.</p>
<p><code>cue_data</code> contains our EEG signal as a tensor (a multidimensional array) with 3 dimensions: time, channel, and trial. Each row is a different time point with respect to cue onset. Each column is a different channel. And each ‘sheet’ (3rd dimension) is a different cue delivery epoch.</p>
<p>Since we are not sure which recording site to focus on at first, we will calculate the average response across all sites. This is easy to do using numpy’s <code>mean</code> function. When calling it, we can indicate the dimensions along which we want the mean to be taken. To get the mean across all trials and channels, we set the <code>axis</code> parameter to (1,2), which corresponds to the channel and trial dimensions.</p>
<div id="2b03b620" class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>cue_erp_all <span class="op">=</span> np.mean(cue_data,axis<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>cue_erp_all.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre><code>(300,)</code></pre>
</div>
</div>
<p>Taking the mean of our <code>cue_data</code> tensor in this way yields a 1-dimensional array with a size that is the number of time points we have per trial: <span class="math display"> \begin{split}
    &amp;= 500\frac{samples}{sec}(0.1 sec + 0.5 sec) \\
    &amp;= 500\frac{samples}{sec} 0.6 sec \\
    &amp;= 300 samples
    \end{split}
</span></p>
<p>Next we want to see what the shape of our average ERP across all channels looks like. In addition, we want to know the latency for its strongest component.</p>
<div id="685f0224" class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get peak time of the cue ERP</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>erp_max_idx <span class="op">=</span> np.argmax(cue_erp_all)</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>erp_peak_time <span class="op">=</span> cue_t[erp_max_idx]</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the cue ERP</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>plt.plot(cue_t, cue_erp_all)</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>plt.scatter(erp_peak_time, np.<span class="bu">max</span>(cue_erp_all), c<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>plt.text(erp_peak_time, np.<span class="bu">max</span>(cue_erp_all), <span class="st">'Peak time: </span><span class="sc">{}</span><span class="st"> ms'</span>.<span class="bu">format</span>( <span class="op">\</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>         <span class="bu">str</span>(<span class="bu">round</span>(erp_peak_time<span class="op">*</span><span class="dv">1000</span>))))</span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Cue ERP averaged across all channels'</span>)</span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-77-output-1.png" width="587" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Here we have a robust ERP in response to the visual cue. It’s first component starts around 90 ms following the cue, and peaks at 120 ms. It is followed by a couple smaller components of opposite polarity.</p>
<p>With the peak time for the first, and strongest component, we can look across all electrodes to see where that component is strongest. A simple way to this is to get the mean ERP across trials for each channel, and then plot the ERP amplitude at that peak time across the scalp. To facilitate this, we created a <code>plot_scalp</code> method for our EEG class that allows us to color the EEG sites based on their voltage.</p>
<div id="a032e5ed" class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate mean ERP for each channel</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>cue_erp_ch <span class="op">=</span> np.mean(cue_data, axis<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'cue_erp_ch has the shape </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(cue_erp_ch.shape))</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="co"># for each channel, get the ERP voltage at the time of the ERP peak</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>cue_scalp <span class="op">=</span> cue_erp_ch[erp_max_idx, :]</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'cue_scalp has the shape </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(cue_scalp.shape))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>cue_erp_ch has the shape (300, 61)
cue_scalp has the shape (61,)</code></pre>
</div>
</div>
<p>When taking the mean of <code>cue_data</code> along the 2nd axis, the trial axis, we get a an array <code>cue_erp_ch</code> that has the ERP for each EEG channel. To find the ERP voltage at each channel for the peak time we identified above, we just get the values from the corresponding row. This gives a vector with with a size equal to the number of channels. We can pass this to the <code>plot_scalp</code> method to visualize the distribution of the first component strengths across the scalp.</p>
<div id="7167d750" class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the ERP scalp topography</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>scalp_ax <span class="op">=</span> eeg.plot_scalp(colors<span class="op">=</span>cue_scalp)</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>plt.colorbar(scalp_ax.collections[<span class="dv">0</span>], label<span class="op">=</span><span class="st">'Amplitude (uV)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-79-output-1.png" width="461" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Amplitudes are colored from yellow to blue, with yellow being the most positive values and blue the lowest/most negative. There is an obvious gradient across the scalp, with sites over the occipital and parietal cortices (O, PO, and P) showing the strongest amplitudes. Those areas where most early visual processing takes place, however the cue stimulus was a sound. Auditory processing tends to occur in the temporal lobe, but the T sites that lie nearest to that structure do not show the strongest response! This underscores the complex relationship between ERP components and the neural activations that underlie them. The expression of a neural activity as scalp potentials depends on the timing and location of that activity, how it is oriented with respect to the curved surface of the cortex, its synchrony with other activities across the cortex, and the its smearing by the dura, cerebrospinal fluid, skull, and skin of the scalp. In theory, if you know all of these things you should be able to perfectly predict the ERP distribution on the scalp, in practice you often only know a few of these factors. Thus, when analyzing ERPs components it is safest to avoid making direct neural inferences about them, e.g.&nbsp;a component over occipital cortex does not necessarily reflect activation of occipital cortex.</p>
<p>Let’s now plot the ERP for the channel it showed its strongest signal. It is hard to tell which one is that from the scalp map above, so instead we will create a list of channels sorted by the strength of their ERP peak voltage from strongest to weakest.</p>
<div id="deb67f0c" class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get sorted indices of cue_scalp</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>max_ch_idx <span class="op">=</span> np.argsort(<span class="op">-</span>cue_scalp) <span class="co"># negate to sort in descending order</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>max_ch <span class="op">=</span> cue_ch[max_ch_idx]</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Strongest -&gt; weakest </span><span class="ch">\n</span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(max_ch))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Strongest -&gt; weakest 
['M1' 'M2' 'PO7' 'PO5' 'P7' 'CB1' 'O1' 'O2' 'F8' 'CB2' 'PO6' 'PO8' 'P8'
 'PO4' 'Oz' 'P5' 'PO3' 'POz' 'TP7' 'P3' 'P2' 'P4' 'P6' 'TP8' 'T7' 'Pz'
 'CP5' 'FT8' 'T8' 'P1' 'C5' 'AF4' 'CP6' 'CP2' 'CP4' 'CP3' 'C6' 'CP1' 'CPz'
 'FT7' 'F7' 'F5' 'FC6' 'FC5' 'AF3' 'FC3' 'C3' 'C1' 'FC1' 'C2' 'C4' 'Cz'
 'F3' 'F1' 'F2' 'F4' 'F6' 'FC4' 'Fz' 'FC2' 'FCz']</code></pre>
</div>
</div>
<p>Notice that M1 and M2, the mastoid sites, came out on top. These are frequently used as reference sites, and so we will instead go to the next strongest site, PO7.</p>
<p>We will plot the ERP on PO7, along with each individual trial so we can visualize the variability of the ERP.</p>
<div id="565598c8" class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get PO7 index</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>sel_chan <span class="op">=</span> <span class="st">'PO7'</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>po7_idx <span class="op">=</span> np.where(cue_ch <span class="op">==</span> sel_chan)[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>po7_idx</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="co"># plot PO7 ERP</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>plt.plot(cue_t, cue_data[:, po7_idx, :], color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>plt.plot(cue_t, cue_erp_ch[:, po7_idx], label<span class="op">=</span><span class="st">'Mean ERP'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'</span><span class="sc">{}</span><span class="st"> ERP'</span>.<span class="bu">format</span>(sel_chan))</span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-81-output-1.png" width="596" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The red line is the mean ERP across all trials and each faded black line is the response on a single trial. There is a remarkable similarity in the ERP shape across trials. Also note the variability in activity before and several hundred milliseconds after the cue. Those activities are <em>spontaneous</em>, and because they lack a consistent relationship with cue onset tend to average out to zero. Thus, using averaging across trials we can isolate the evoked component of the EEG.</p>
<p><span class="math display"> ERP = Neural_{evoked} + \cancel{Neural_{spon}} </span></p>
</section>
</section>
<section id="intersubject-variability" class="level2">
<h2 class="anchored" data-anchor-id="intersubject-variability">Intersubject variability</h2>
<p>An ERP can be consistent across trials and sessions when taken from the same subject, but between subjects there may be a great deal of variability. This goes back to the complex relationship between patterns of brain activation, geometry of the brain surface and skull, and their reflection on the scalp. Any variations in these factors between individuals that affect that relationship can impact the expression of the ERP. As a consequence, it is important to examine the ERP within each subject separately. Now that we have all the code worked out for loading, preprocessing, and extracting ERPs, we can quickly apply them to a new subject.</p>
<div id="d8c026ee" class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get EEG file names for subject AB64</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="co"># get file paths</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>subj2 <span class="op">=</span> <span class="st">'sub-AB64'</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>chan_dir2 <span class="op">=</span> [<span class="st">'.'</span>, <span class="st">'data'</span>, <span class="st">'eeg'</span>, <span class="st">'ds003690'</span>, subj2, <span class="st">'eeg'</span>, <span class="st">'</span><span class="sc">{}</span><span class="st">_task-passive_run-1_channels.tsv'</span>.<span class="bu">format</span>(subj2)]</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>chan_file2 <span class="op">=</span> op.join(<span class="op">*</span>chan_dir2) <span class="co"># use * to unpack the list</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>data_dir2 <span class="op">=</span> [<span class="st">'.'</span>, <span class="st">'data'</span>, <span class="st">'eeg'</span>, <span class="st">'ds003690'</span>, subj2, <span class="st">'eeg'</span>, <span class="st">'</span><span class="sc">{}</span><span class="st">_task-passive_run-1_eeg.set'</span>.<span class="bu">format</span>(subj2)]</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>eeg_file2 <span class="op">=</span> op.join(<span class="op">*</span>data_dir2) <span class="co"># use * to unpack the list</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>evt_dir2 <span class="op">=</span> [<span class="st">'.'</span>, <span class="st">'data'</span>, <span class="st">'eeg'</span>, <span class="st">'ds003690'</span>, subj2, <span class="st">'eeg'</span>, <span class="st">'</span><span class="sc">{}</span><span class="st">_task-passive_run-1_events.tsv'</span>.<span class="bu">format</span>(subj2)]</span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>evt_file2 <span class="op">=</span> op.join(<span class="op">*</span>evt_dir2) <span class="co"># use * to unpack the list</span></span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>events2 <span class="op">=</span> pd.read_csv(evt_file2, sep<span class="op">=</span><span class="st">'</span><span class="ch">\t</span><span class="st">'</span>)</span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a><span class="co"># create an EEG object</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>eeg2 <span class="op">=</span> EEG(eeg_file2, chan_file2)</span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a><span class="co"># remove noise from EEG data</span></span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a>remove_baseline_drift(eeg2)</span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>remove_emg(eeg2)</span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>remove_ac(eeg2, <span class="dv">50</span>)</span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a><span class="co"># exclude cue events near blinks</span></span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a><span class="co"># get cue times</span></span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a>cue_times2 <span class="op">=</span> events2.loc[events2[<span class="st">'trial_type'</span>] <span class="op">==</span> <span class="st">'cue'</span>][<span class="st">'onset'</span>].values</span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a>blink_times2, _ <span class="op">=</span> detect_blinks(eeg2, eog_chan<span class="op">=</span><span class="st">'HEO'</span>)</span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a>valid_cue_times2, valid_percent2 <span class="op">=</span> remove_blink_epochs(cue_times2, blink_times2, excl_period)</span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Valid cue times percentage: </span><span class="sc">{}</span><span class="st">%'</span>.<span class="bu">format</span>(valid_percent2))</span>
<span id="cb112-26"><a href="#cb112-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-27"><a href="#cb112-27" aria-hidden="true" tabindex="-1"></a><span class="co"># get epochs</span></span>
<span id="cb112-28"><a href="#cb112-28" aria-hidden="true" tabindex="-1"></a><span class="co"># window settings</span></span>
<span id="cb112-29"><a href="#cb112-29" aria-hidden="true" tabindex="-1"></a>pre_window <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb112-30"><a href="#cb112-30" aria-hidden="true" tabindex="-1"></a>post_window <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb112-31"><a href="#cb112-31" aria-hidden="true" tabindex="-1"></a>epoch_dur <span class="op">=</span> pre_window <span class="op">+</span> post_window</span>
<span id="cb112-32"><a href="#cb112-32" aria-hidden="true" tabindex="-1"></a>epoch_starts2 <span class="op">=</span> valid_cue_times2 <span class="op">-</span> <span class="fl">0.1</span></span>
<span id="cb112-33"><a href="#cb112-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-34"><a href="#cb112-34" aria-hidden="true" tabindex="-1"></a><span class="co"># load epochs</span></span>
<span id="cb112-35"><a href="#cb112-35" aria-hidden="true" tabindex="-1"></a>cue_data2, cue_t2, cue_ch2 <span class="op">=</span> eeg2.get_data(chans<span class="op">=</span><span class="st">'eeg'</span>, start_t<span class="op">=</span>epoch_starts2, </span>
<span id="cb112-36"><a href="#cb112-36" aria-hidden="true" tabindex="-1"></a>                       dur_t<span class="op">=</span>epoch_dur, scale<span class="op">=</span><span class="st">'relative'</span>)</span>
<span id="cb112-37"><a href="#cb112-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-38"><a href="#cb112-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Mean ERP across all sites</span></span>
<span id="cb112-39"><a href="#cb112-39" aria-hidden="true" tabindex="-1"></a>cue_erp_all2 <span class="op">=</span> np.mean(cue_data2, axis<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb112-40"><a href="#cb112-40" aria-hidden="true" tabindex="-1"></a>erp_max_idx2 <span class="op">=</span> np.argmax(cue_erp_all2)</span>
<span id="cb112-41"><a href="#cb112-41" aria-hidden="true" tabindex="-1"></a>erp_peak_time2 <span class="op">=</span> cue_t2[erp_max_idx2]<span class="op">-</span>pre_window</span>
<span id="cb112-42"><a href="#cb112-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-43"><a href="#cb112-43" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>))</span>
<span id="cb112-44"><a href="#cb112-44" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(cue_t2<span class="op">-</span>pre_window, cue_erp_all2)</span>
<span id="cb112-45"><a href="#cb112-45" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].scatter(erp_peak_time2, np.<span class="bu">max</span>(cue_erp_all2), c<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb112-46"><a href="#cb112-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-47"><a href="#cb112-47" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].text(erp_peak_time2, np.<span class="bu">max</span>(cue_erp_all2), <span class="st">'Peak time: </span><span class="sc">{}</span><span class="st"> ms'</span>.<span class="bu">format</span>( <span class="op">\</span></span>
<span id="cb112-48"><a href="#cb112-48" aria-hidden="true" tabindex="-1"></a>         <span class="bu">str</span>(<span class="bu">round</span>(erp_peak_time2<span class="op">*</span><span class="dv">1000</span>))))</span>
<span id="cb112-49"><a href="#cb112-49" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">'Time (sec)'</span>)</span>
<span id="cb112-50"><a href="#cb112-50" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb112-51"><a href="#cb112-51" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">'Cue ERP averaged across all channels'</span>)</span>
<span id="cb112-52"><a href="#cb112-52" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].grid(<span class="va">True</span>)</span>
<span id="cb112-53"><a href="#cb112-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-54"><a href="#cb112-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot scalp topography of the ERP at the peak time</span></span>
<span id="cb112-55"><a href="#cb112-55" aria-hidden="true" tabindex="-1"></a>cue_erp_ch2 <span class="op">=</span> np.mean(cue_data2, axis<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb112-56"><a href="#cb112-56" aria-hidden="true" tabindex="-1"></a>cue_scalp2 <span class="op">=</span> cue_erp_ch2[erp_max_idx2, :]</span>
<span id="cb112-57"><a href="#cb112-57" aria-hidden="true" tabindex="-1"></a>eeg2.plot_scalp(ax<span class="op">=</span>ax[<span class="dv">1</span>], colors<span class="op">=</span>cue_scalp2)</span>
<span id="cb112-58"><a href="#cb112-58" aria-hidden="true" tabindex="-1"></a>plt.colorbar(ax[<span class="dv">1</span>].collections[<span class="dv">0</span>], label<span class="op">=</span><span class="st">'Amplitude (uV)'</span>)</span>
<span id="cb112-59"><a href="#cb112-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-60"><a href="#cb112-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-61"><a href="#cb112-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot ERP for the channel with the strongest ERP</span></span>
<span id="cb112-62"><a href="#cb112-62" aria-hidden="true" tabindex="-1"></a>cue_max_data, cue_max_t, cue_max_ch <span class="op">=</span> eeg2.get_data(chans<span class="op">=</span><span class="st">'O1'</span>, start_t<span class="op">=</span>epoch_starts2, </span>
<span id="cb112-63"><a href="#cb112-63" aria-hidden="true" tabindex="-1"></a>                       dur_t<span class="op">=</span>epoch_dur, scale<span class="op">=</span><span class="st">'relative'</span>)</span>
<span id="cb112-64"><a href="#cb112-64" aria-hidden="true" tabindex="-1"></a>cue_max_erp <span class="op">=</span> np.mean(cue_max_data, axis<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb112-65"><a href="#cb112-65" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>))</span>
<span id="cb112-66"><a href="#cb112-66" aria-hidden="true" tabindex="-1"></a>ax.plot(cue_t2, cue_max_data.squeeze(), color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb112-67"><a href="#cb112-67" aria-hidden="true" tabindex="-1"></a>ax.plot(cue_max_t, cue_max_erp.squeeze(), color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb112-68"><a href="#cb112-68" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (sec)'</span>)</span>
<span id="cb112-69"><a href="#cb112-69" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Voltage (uV)'</span>)</span>
<span id="cb112-70"><a href="#cb112-70" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Cue ERP for channel </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(cue_max_ch))</span>
<span id="cb112-71"><a href="#cb112-71" aria-hidden="true" tabindex="-1"></a>ax.grid(<span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Valid cue times percentage: 100.0%</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-82-output-2.png" width="838" height="449" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week2_files/figure-html/cell-82-output-3.png" width="819" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The time course of the ERP in this subject is substantially different from the previous one. Here we only see one prominent peak, and at a longer latency (~100 ms later). On the other hand, the scalp topography of that component is similar, with the strongest sites being occipital and parietal. The ERP does appear more lateralized, however, with the ERP stronger in the left hemisphere.</p>
<p>Let’s not waste this hard work, we should try to save our data for use in Week 3. Fortunately, Numpy arrays can be saved as their own files.</p>
<div id="1b9f64da" class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>save_dir <span class="op">=</span> os.path.join(<span class="op">*</span>[<span class="st">'.'</span>, <span class="st">'Week3'</span>, <span class="st">'data'</span>, <span class="st">'ds003690'</span>])</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Only write out the data if the directory doesn't exist</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="co"># This is to prevent overwriting the data</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(save_dir):</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>    os.mkdir(save_dir)</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>    subj <span class="op">=</span> <span class="st">'AB58'</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>    np.save(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_data.npy'</span>), eeg.data)</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>    np.save(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_srate.npy'</span>), eeg.srate)</span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>    np.save(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_blinks.npy'</span>), blink_times)</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>    np.save(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_cues.npy'</span>), cue_times)</span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>    eeg.chans.to_csv(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_chans.tsv'</span>), sep<span class="op">=</span><span class="st">'</span><span class="ch">\t</span><span class="st">'</span>)</span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>    subj <span class="op">=</span> <span class="st">'AB64'</span></span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>    np.save(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_data.npy'</span>), eeg2.data)</span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>    np.save(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_srate.npy'</span>), eeg2.srate)</span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>    np.save(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_blinks.npy'</span>), blink_times2)</span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>    np.save(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_cues.npy'</span>), cue_times2)</span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a>    eeg2.chans.to_csv(os.path.join(save_dir, subj <span class="op">+</span> <span class="st">'_chans.tsv'</span>), sep<span class="op">=</span><span class="st">'</span><span class="ch">\t</span><span class="st">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>