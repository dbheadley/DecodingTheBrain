<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Week 1 – Decoding The Brain</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Decoding The Brain</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.qmd"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./Week1.html" aria-current="page"> 
<span class="menu-text">Week 1</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Week2.html"> 
<span class="menu-text">Week 2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Week3.html"> 
<span class="menu-text">Week3</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Week4.html"> 
<span class="menu-text">Week 4</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="./about.qmd"> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#syllabus-and-class-structure" id="toc-syllabus-and-class-structure" class="nav-link active" data-scroll-target="#syllabus-and-class-structure">Syllabus and class structure</a></li>
  <li><a href="#mixing-code-theory-and-practice" id="toc-mixing-code-theory-and-practice" class="nav-link" data-scroll-target="#mixing-code-theory-and-practice">Mixing code, theory, and practice</a></li>
  <li><a href="#general-principles-of-bci-design" id="toc-general-principles-of-bci-design" class="nav-link" data-scroll-target="#general-principles-of-bci-design">General principles of BCI design</a></li>
  <li><a href="#neuroscience-basics" id="toc-neuroscience-basics" class="nav-link" data-scroll-target="#neuroscience-basics">Neuroscience basics</a>
  <ul class="collapse">
  <li><a href="#brain-anatomy" id="toc-brain-anatomy" class="nav-link" data-scroll-target="#brain-anatomy">Brain anatomy</a></li>
  <li><a href="#neurons" id="toc-neurons" class="nav-link" data-scroll-target="#neurons">Neurons</a></li>
  <li><a href="#membranes-and-ions" id="toc-membranes-and-ions" class="nav-link" data-scroll-target="#membranes-and-ions">Membranes and ions</a></li>
  </ul></li>
  <li><a href="#electrical-model-of-the-neuronal-membrane" id="toc-electrical-model-of-the-neuronal-membrane" class="nav-link" data-scroll-target="#electrical-model-of-the-neuronal-membrane">Electrical model of the neuronal membrane</a>
  <ul class="collapse">
  <li><a href="#equilibrium-potential-as-a-battery-and-conductor" id="toc-equilibrium-potential-as-a-battery-and-conductor" class="nav-link" data-scroll-target="#equilibrium-potential-as-a-battery-and-conductor">Equilibrium potential as a battery and conductor</a></li>
  <li><a href="#membrane-as-a-capacitor" id="toc-membrane-as-a-capacitor" class="nav-link" data-scroll-target="#membrane-as-a-capacitor">Membrane as a capacitor</a></li>
  <li><a href="#passive-electrical-model-of-the-membrane" id="toc-passive-electrical-model-of-the-membrane" class="nav-link" data-scroll-target="#passive-electrical-model-of-the-membrane">Passive electrical model of the membrane</a></li>
  <li><a href="#creating-a-passive-neuron-model" id="toc-creating-a-passive-neuron-model" class="nav-link" data-scroll-target="#creating-a-passive-neuron-model">Creating a passive neuron model</a></li>
  <li><a href="#action-potentials" id="toc-action-potentials" class="nav-link" data-scroll-target="#action-potentials">Action potentials</a></li>
  <li><a href="#creating-a-simplified-active-neuron-model" id="toc-creating-a-simplified-active-neuron-model" class="nav-link" data-scroll-target="#creating-a-simplified-active-neuron-model">Creating a simplified active neuron model</a></li>
  <li><a href="#synapses" id="toc-synapses" class="nav-link" data-scroll-target="#synapses">Synapses</a></li>
  </ul></li>
  <li><a href="#detecting-the-activity-of-neurons" id="toc-detecting-the-activity-of-neurons" class="nav-link" data-scroll-target="#detecting-the-activity-of-neurons">Detecting the activity of neurons</a>
  <ul class="collapse">
  <li><a href="#physics-of-extracellular-potentials" id="toc-physics-of-extracellular-potentials" class="nav-link" data-scroll-target="#physics-of-extracellular-potentials">Physics of extracellular potentials</a></li>
  <li><a href="#modeling-the-relationship-between-electrode-distance-and-recorded-potential" id="toc-modeling-the-relationship-between-electrode-distance-and-recorded-potential" class="nav-link" data-scroll-target="#modeling-the-relationship-between-electrode-distance-and-recorded-potential">Modeling the relationship between electrode distance and recorded potential</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Week 1</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="syllabus-and-class-structure" class="level2">
<h2 class="anchored" data-anchor-id="syllabus-and-class-structure">Syllabus and class structure</h2>
<p>Welcome to the course <em>Decoding the Brain</em>. We will cover how to process electrical signals generated by neural activity, use machine learning approaches to infer the presentation of stimuli or an intended motor action from that activity, and evaluate the performance of these inferences.</p>
<p>This course is designed so that students gain a practical understanding of how to design the algorithms used for brain-computer interfaces (BCI). By the end of the course, you should understand enough to program your own BCI algorithms for non-invasive (scalp) and invasive (electrodes implanted in the brain) measures of brain activity. These activities can be weak electrical activity recorded from the scalp (EEG), high-frequency oscillations recorded on the brain surface (ECoG), and the firing of individual neurons (units). Decoding each of these types of signals requires several steps we will cover. First, you will be shown how to process and clean them for subsequent decoding. Then, we will cover the theory behind how the decoding algorithms work and code basic versions of them from scratch in using the Python packages Numpy or PyTorch. Next, we will expand their capabilities to handle more complex patterns of brain activity or decode multiple events. Finally, we will evaluate the decoder’s performance.</p>
<p>Except for cursory discussion, we will not cover the hardware, surgical, and biocompatibility issues of recording brain activity. Those topics depend upon fundamentally different skills from the design of BCI algorithms.</p>
<p>The two principal algorithms covered in this course, logistic regression and naive Bayes, are useful outside of BCIs. Thus, the understanding you get of them here will apply to many other domains.</p>
</section>
<section id="mixing-code-theory-and-practice" class="level2">
<h2 class="anchored" data-anchor-id="mixing-code-theory-and-practice">Mixing code, theory, and practice</h2>
<p>Lectures will introduce the theory behind what we do, practical details of how to go about doing it, and code that does the doing. The astounding thing about BCI design is how accessible the algorithms and plentiful the data sources are. Of course, a real BCI system uses specialized hardware implanted in or on a person and is run in near real-time, which is not feasible in a classroom setting.</p>
<p>We will use Python throughout this course, and publicly available data sets.</p>
<div id="4df062ad" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This will be the standard set of packages we import for most lectures. </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.signal <span class="im">as</span> sig</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, Math, Latex    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="general-principles-of-bci-design" class="level2">
<h2 class="anchored" data-anchor-id="general-principles-of-bci-design">General principles of BCI design</h2>
<p>The goal of BCI is to attribute electrical activity in a subject’s brain to stimuli they received or actions they intended to produce. Grounding this is the fundamental assumption in neuroscience that all we experience and do arises from patterns of activity in the brain. These patterns are manifested at multiple levels, from single neurons to large portions of the cortical surface. Every stimulus produces a chain of activities starting at peripheral receptors, ascending through chains of neurons that eventually reach the neocortex, where they are processed and elaborated, linked with your expectations, memories, and goals. At every level specific groups of neurons are activated reflecting the properties of the stimuli or your cognitive state. Sometimes these trigger actions - e.g.&nbsp;moving your arm - that depends on a chain of activities stretching back from the muscles to your spinal cord, then brain stem, then cortex. Remarkably, in a mouse it only takes the activation of just over a dozen neurons to <a href="https://elifesciences.org/articles/58889">influence perception</a>.</p>
<p>Given that there is a physical correlate in the brain of what we perceive and do, then it is possible to ‘tap’ them. The limitations are technical such as how well can be extract neural activities and our computational resources for attributing them to the external world. Much work has been spent on these problems. This is often conceptualized in two different ways.</p>
<p><img src="./images/DecodingEncoding.png" class="img-fluid" alt="Encoding and decoding">.</p>
<p>One is treat it as an <em>encoding</em> problem, where we try to understand how events in the environment are reflected in neural activities. The other is the <em>decoding</em> approach, where we use neural activities to infer what is happening in the environment. BCIs make extensive use of decoding analyses.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/BCI_Schema.png" class="img-fluid figure-img"></p>
<figcaption>BCI schema</figcaption>
</figure>
</div>
<p>A BCI involves measuring some activity in the brain and then transforming it so that it can be used to infer whether a certain action was intended or stimulus occurred. The transformation, referred to as the decoding step in the above figure, involves three steps. 1. Signal preprocesing: The raw neural activity measurements are cleaned and filtered to remove non-neural artifacts and highlight those aspects of the signal that reflect the processing we care about. 2. Feature extraction: Patterns are identified in the activities that are related to the events we wish to decode. 3. Classification: Based on the detected patterns, a decision is made about whether, or what kind, of event occurred.</p>
<p>For each type of brain signal involves different preprocessing and feature extraction steps. Generally the classification step can be used interchangeably between signal types, but we will explore two fundamentally different approaches.</p>
</section>
<section id="neuroscience-basics" class="level2">
<h2 class="anchored" data-anchor-id="neuroscience-basics">Neuroscience basics</h2>
<p>The brain is an electrochemical machine that allows vertebrates to interact with a dynamic complex environment. It does this using specialized cells called <em>neurons</em>. They have the ability to receive chemical signals, <em>neurotransmitters</em>, that affect their electrical activity. This activity is transmitted to other neurons via an <em>axon</em>. When multiple neurons are connected together they form a network that supports the transformation of incoming activity and spontaneous generation of new activities.</p>
<section id="brain-anatomy" class="level3">
<h3 class="anchored" data-anchor-id="brain-anatomy">Brain anatomy</h3>
<p>The brain is composed of numerous regions, but its cortex is generally divided into four principal areas: <img src="./images/brain-lobes-anatomy-johnshopkins.jpg" class="img-fluid" alt="brain"></p>
<ol type="1">
<li>Frontal lobe: Reasoning and motor control</li>
<li>Parietal lobe: Touch and visual spatial processing</li>
<li>Occipital lobe: Low level visual processing</li>
<li>Temporal lobe: Audition, high level visual processing, memory</li>
</ol>
<p>Keep in mind these are gross generalizations regarding the function of these areas.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/AnatomyCrosssection.png" class="img-fluid figure-img"></p>
<figcaption>Brain cross section</figcaption>
</figure>
</div>
<p>The brain is situated in the skull and is separated by a couple centimeters from the surface of the scalp. Above it lies several layers of connective tissue (pia, dura, arachnoid) and cerebrospinal fluid that act as a protective cushion. The skull itself has multiple layers, followed by fatty tissue and the skin.</p>
</section>
<section id="neurons" class="level3">
<h3 class="anchored" data-anchor-id="neurons">Neurons</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/NeuronSchematic-Hammond.png" class="img-fluid figure-img"></p>
<figcaption>Neuron schematic</figcaption>
</figure>
</div>
<p>Neurons are the principal cell type in the brain for processing information. Neurons are tiny, ~10 microns, which is 5-10 times smaller than the diameter of a human hair. They are comprised of a soma (cell body), dendrites, and an axon. The dendrites take in signals from other neurons, integrate them, and convey them to the soma. When these signals exceed a threshold, the soma can generate an <em>action potential</em> that is conveyed down the axon towards other neurons.</p>
</section>
<section id="membranes-and-ions" class="level3">
<h3 class="anchored" data-anchor-id="membranes-and-ions">Membranes and ions</h3>
<p><img src="./images/FluidMosaic-Hammond.png" class="img-fluid" alt="Structure of the neuron membrane"> Like all eukaryotic cells, neurons have a lipid membrane that seals in their internal, or <em>intracellular</em>, fluid (also known as cytoplasm) and organelles from the <em>extracellular</em> environment. This membrane also acts as an electrical insulator, blocking the flow of electrical charges across it. Electrical charge in the brain is carried by <em>ions</em> in the intracellular and extracellular fluids (cerebrospinal fluid). Ions are atoms or molecules that are either positively or negatively charged depending on whether they have a fewer or greater number of electrons than protons. The ones that are most determinative of neural activity are Na<sup>+</sup>, K<sup>+</sup>, Cl<sup>-</sup>, and Ca<sup>2+</sup>. Between the intracellular and extracellular fluids, the concentrations of these ions are different. Na<sup>+</sup>,Cl<sup>-</sup>, and Ca<sup>2+</sup> have higher concentrations in the extracellular fluid, while K<sup>+</sup> ions have a higher concentration in the intracellular fluid.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/Nernst_USMLE.jpg" class="img-fluid figure-img"></p>
<figcaption>Membrane and ions</figcaption>
</figure>
</div>
<div id="648a2d46" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ion_props <span class="op">=</span> pd.DataFrame({<span class="st">'Ion'</span>: [<span class="st">'Na'</span>, <span class="st">'K'</span>, <span class="st">'Cl'</span>, <span class="st">'Ca'</span>],</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                          <span class="st">'Out_mM'</span>: [<span class="dv">140</span>, <span class="dv">3</span>, <span class="dv">140</span>, <span class="fl">1.5</span>],</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                          <span class="st">'In_mM'</span>: [<span class="dv">7</span>, <span class="dv">140</span>, <span class="dv">7</span>, <span class="fl">0.0001</span>],</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                          <span class="st">'Charge'</span>: [<span class="dv">1</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>]})</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>ion_props.set_index(<span class="st">'Ion'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ion_props)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     Out_mM     In_mM  Charge
Ion                          
Na    140.0    7.0000       1
K       3.0  140.0000       1
Cl    140.0    7.0000      -1
Ca      1.5    0.0001       2</code></pre>
</div>
</div>
<p>This unequal distribution of ions across the membrane is unstable because ions tend to flow from where they are highly concentrated to where they are less concentrated. To cross the membrane, ions flow through channels, unsurprisingly called <em>ion channels</em>. These are proteins that span the inside and outside of the neuron with a central hole, known as a pore, through which the ions flow. The pore’s shape and charge determine its selectivity for specific ionic species. Additional factors can control the opening of the pore. Some ion channel pores are controlled by the voltage across the membrane, others by substances such as neurotransmitters or hormones that bind to them, or even other ions like Mg<sup>2+</sup>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/NaChannel_Sula2017.jpg" class="img-fluid figure-img"></p>
<figcaption>Na channel</figcaption>
</figure>
</div>
<p>Since ions move from high to low concentrations, Na<sup>+</sup>, Cl<sup>-</sup>, and Ca<sup>2+</sup> are inclined to flow into neurons. K<sup>+</sup>, on the other hand, wants to flow out of the neuron. As these ions flow through the membrane they build up on its surface. This create a force that opposes further flow from diffusion, because ions with the same sign to their charge tend to push away from each other. The work needed to move a charge from one place to another is measured as a <em>voltage</em> or <em>potential</em>. The potential at which an ion’s electrical forces from the buildup of ions balance out the diffusion force is referred to as the <em>reversal</em> or <em>equilibrium potential</em>, E. In the case here, we are measuring potential between the inside and outside of the neuron. We can calculate the strength of the potentials that reflect these drives using the Nernst equation.</p>
<p><span class="math display">E = \frac{RT}{zF}ln\frac{[Out]}{[In]}</span></p>
<p><span class="math inline">R</span> is the gas constant and <span class="math inline">F</span> is Faraday’s constant, while <span class="math inline">T</span> is temperature in Kelvin and <span class="math inline">z</span> is the charge of the ion. <span class="math inline">[Out]</span> and <span class="math inline">[In]</span> are the extracellular and intracellular concentrations of that ion, respectively.</p>
<p>Most of the time when an equation is introduced, we will try to translate it into Python. A method that calculates the equilibrium potential of a given ion can be given as:</p>
<div id="c6064a3c" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate Nernst equilibrium potential for an ion</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nernst(conco<span class="op">=</span><span class="dv">3</span>, conci<span class="op">=</span><span class="dv">140</span>, z<span class="op">=</span><span class="dv">1</span>, t<span class="op">=</span><span class="dv">310</span>):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate Nernst potential for an ion.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">    conco : float</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">        Concentration of ion outside cell (mM). Default is for K+.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">    conci : float</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">        Concentration of ion inside cell (mM). Default is for K+.</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">    z : int</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">        Charge of ion.  Default is for K+.</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">    t : float</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">        Temperature (Kelvin). Default is body temperature.</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co">    float</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="co">        Nernst potential for ion (mV).</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="fl">8.314</span> <span class="co"># J/mol/K, gas constant</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> <span class="dv">96485</span> <span class="co"># C/mol, Faraday's constant</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (r<span class="op">*</span>t)<span class="op">/</span>(z<span class="op">*</span>f) <span class="op">*</span> np.log(conco<span class="op">/</span>conci) <span class="op">*</span> <span class="dv">1000</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Using this function and the dataframe of ionic concentrations above, we can calculate the equilibrium potentials for each of the major ionic species found in the nervous system.</p>
<div id="1ea66563" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ion_props[<span class="st">'E'</span>] <span class="op">=</span> ion_props.<span class="bu">apply</span>(<span class="kw">lambda</span> ion: nernst(ion[<span class="st">'Out_mM'</span>], ion[<span class="st">'In_mM'</span>], ion[<span class="st">'Charge'</span>]), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ion_props)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     Out_mM     In_mM  Charge           E
Ion                                      
Na    140.0    7.0000       1   80.023015
K       3.0  140.0000       1 -102.656323
Cl    140.0    7.0000      -1  -80.023015
Ca      1.5    0.0001       2  128.430326</code></pre>
</div>
</div>
<p>Several insights are readily apparent from cursory inspection of the calculated equilibrium potentials and consideration of the Nernst equation. First, and most importantly, positive ions that have a higher concentration outside the neuron will have positive potentials, while those more concentrated inside the neuron have negative potentials. This is stands out when comparing the potential of Na<sup>+</sup>, whose potential is 80 mV and K<sup>+</sup>, whose potential is -80 mV. Second, since we are taking the ratio between <span class="math inline">[Out]</span> and <span class="math inline">[In]</span>, the overall amount of ions in our system does not affect the potential, only their relative proportion. Put another way, you could decrease the concentration of Na<sup>+</sup> ions inside and outside the neuron by ten times and as long as they have the same proportion, the potential will be unchanged. Indeed, Ca<sup>2+</sup> has a much lower overall concentration inside and outside the membrane, but its reversal potential is higher than that for Na<sup>+</sup>. Third, if an ion has a negative charge, <span class="math inline">z</span>, it flips the sign of the potential. For instance, Cl<sup>-</sup> ions have a higher concentration outside the neuron, just like Na<sup>+</sup>, but their potential is negative.</p>
<p>The potential across a neuron’s membrane is the mean of all these potentials, each weighted by how easy it is for the ion to cross the membrane, which is related to the number of open ion channels allowing that ion to flow. In a neuron at rest, mostly K<sup>+</sup> ion channels are open, so its reversal potential dominates. Neurons in the cerebral cortex usually have a resting potential around -65 mV.</p>
</section>
</section>
<section id="electrical-model-of-the-neuronal-membrane" class="level2">
<h2 class="anchored" data-anchor-id="electrical-model-of-the-neuronal-membrane">Electrical model of the neuronal membrane</h2>
<p>The electrical behavior of the membrane can be approximated by a relatively simple circuit. While this is not an electronics course, I will briefly describe this model and use it to construct a simulated neuron. This should allow us to explore some of the response properties of neurons and how they are reflected in the electrical activities detected with electrodes.</p>
<section id="equilibrium-potential-as-a-battery-and-conductor" class="level3">
<h3 class="anchored" data-anchor-id="equilibrium-potential-as-a-battery-and-conductor">Equilibrium potential as a battery and conductor</h3>
<p>The equilibrium potential, <span class="math inline">E_{r}</span>, behaves like a battery. The ionic current it produces flows through open ion channels, which we will refer to as conductors. As we discussed above, when a neuron is at rest it primarily allows K<sup>+</sup> ions to flow. This passive leakage of ions across the membrane has given the conductance the name <em>leak conductance</em>. This can be schematized below as a battery and conductor in series that bridge the intracellular and extracellular spaces.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/MemBatRes.png" class="img-fluid figure-img"></p>
<figcaption>Membrane with battery</figcaption>
</figure>
</div>
<p>By itself, this circuit will fix the voltage across the neuronal membrane (measured between the inside and outside) at the resting potential. Normally neurons do not remain at rest, but have a ongoing fluctuations in their membrane voltage due to the thousands of synaptic inputs they recieve. This means that the membrane potential, <span class="math inline">V_{m}</span>, can be different from <span class="math inline">E_{r}</span>. When <span class="math inline">V_{m}</span> is different from <span class="math inline">E_{r}</span>, there is a net flow of current across the membrane, since the electrical and diffusion forces are no longer balanced (think back to the Nernst equation). The ionic current can be described using Ohm’s law:</p>
<p><span class="math display"> V = IR </span></p>
<p>where <span class="math inline">V</span> is voltage (volts, V), <span class="math inline">I</span> is current (amperes, A), and <span class="math inline">R</span> is resistance (ohms, <span class="math inline">\Omega</span>). Rewriting the equation to solve for <span class="math inline">I</span> gives us: <span class="math display"> I = \frac{V}{R} </span> The inverse of resistance is conductance (siemens, S), so this equation can be rewritten as: <span class="math display"> I = gV </span> Here <span class="math inline">g</span> is the ease with which our conductor allows current to flow. Now, if we include the effect of the reversal potential, <span class="math inline">E_{r}</span> acting as a battery, then the equation can be written as: <span class="math display"> I_{leak} = g_{leak}(V_{m}-E_{r}) \tag{1} </span> Let’s consider the behavior of this equation. It shows that as we increase the ion channel’s conductance, <span class="math inline">g_{leak}</span>, the current will increase as well. It also shows that the magnitude and direction of the current will depend on the membrane voltage, <span class="math inline">V_{m}</span>. If <span class="math inline">V_{m}</span> is below <span class="math inline">E_{r}</span>, current will be negative. If it is above, then it will be positive. As <span class="math inline">V_{m}</span> approaches <span class="math inline">E_{r}</span>, the current gets smaller. When they are equal, no current flows because the electrical forces perfectly balance the concentration gradient.</p>
<p>Let’s graph these relationships between <span class="math inline">V_{m}</span> and <span class="math inline">I_{leak}</span> by systematically varying <span class="math inline">E_{r}</span> and <span class="math inline">g_{leak}</span>.</p>
<div id="194f6d27" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Here are somme realistic parameters for a neuron</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>mem_r <span class="op">=</span> <span class="fl">25e3</span> <span class="co"># ohm*cm^2, taken from Egger et al 2020</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>cell_radius <span class="op">=</span> <span class="fl">30e-4</span> <span class="co"># cm, 30 microns, this is larger than the cell body itself to account for membrane from dendrites</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>cell_area <span class="op">=</span> <span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cell_radius<span class="op">**</span><span class="dv">2</span> <span class="co"># cm^2</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>g_leak <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>mem_r) <span class="op">*</span> cell_area <span class="co"># S/cm^2</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>e_rest <span class="op">=</span> <span class="op">-</span><span class="fl">0.065</span> <span class="co"># V, 65 mV</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co"># code for solving for leak current</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ionic_current(v<span class="op">=</span><span class="dv">0</span>, g<span class="op">=</span>g_leak, e<span class="op">=</span>e_rest):</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate ionic current.</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">    v : float</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Membrane potential (V). Default is 0.</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">    g : float</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Conductance (S). Default is leak conductance.</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co">    e : float</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co">        Equilibrium potential (V). Default is resting potential.</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co">    float</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="co">        Ionic current (A).</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g <span class="op">*</span> (v <span class="op">-</span> e)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ea2f35e2" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Examine how varying the conductance affects the I-V curve</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="dv">100</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>g_factors <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ind, curr_factor <span class="kw">in</span> <span class="bu">enumerate</span>(g_factors):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    curr_g <span class="op">=</span> g_leak<span class="op">*</span>curr_factor</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    plt.plot(v<span class="op">*</span><span class="fl">1e3</span>, ionic_current(v, g<span class="op">=</span>curr_g)<span class="op">*</span><span class="fl">1e12</span>, </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>             label<span class="op">=</span><span class="bu">round</span>(curr_g<span class="op">*</span><span class="fl">1e12</span>), color<span class="op">=</span>[ind<span class="op">/</span><span class="bu">len</span>(g_factors), <span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    plt.text(v[<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span><span class="fl">1e3</span><span class="op">+</span><span class="dv">2</span>, ionic_current(v[<span class="op">-</span><span class="dv">1</span>], g<span class="op">=</span>curr_g)<span class="op">*</span><span class="fl">1e12</span>,</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                <span class="bu">str</span>(<span class="bu">round</span>(curr_g<span class="op">*</span><span class="fl">1e12</span>))<span class="op">+</span><span class="st">' pS'</span>, color<span class="op">=</span>[ind<span class="op">/</span><span class="bu">len</span>(g_factors), <span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="op">-</span><span class="dv">100</span>, <span class="dv">135</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Membrane potential (mV)'</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Ionic current (pA)'</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Effect of conductance on ionic current'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>Text(0.5, 1.0, 'Effect of conductance on ionic current')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-7-output-2.png" width="613" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>It is evident that increasing the conductance dramatically increases the ionic current. Now let’s examine the effect of equilibrium potential.</p>
<div id="b78e2bf8" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Examine how varying the equilibrium potential affects the I-V curve</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="dv">100</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>e_values <span class="op">=</span> [<span class="op">-</span><span class="fl">0.070</span>, <span class="op">-</span><span class="fl">0.035</span>, <span class="dv">0</span>, <span class="fl">0.035</span>, <span class="fl">0.070</span>]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ind, curr_e <span class="kw">in</span> <span class="bu">enumerate</span>(e_values):</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    plt.plot(v<span class="op">*</span><span class="fl">1e3</span>, ionic_current(v, e<span class="op">=</span>curr_e)<span class="op">*</span><span class="fl">1e12</span>, </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>             label<span class="op">=</span>curr_e<span class="op">*</span><span class="fl">1e3</span>, color<span class="op">=</span>[<span class="dv">0</span>,<span class="dv">0</span>,ind<span class="op">/</span><span class="bu">len</span>(e_values)])</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    plt.text(v[<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span><span class="fl">1e3</span><span class="op">+</span><span class="dv">2</span>, ionic_current(v[<span class="op">-</span><span class="dv">1</span>], e<span class="op">=</span>curr_e)<span class="op">*</span><span class="fl">1e12</span>,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                <span class="bu">str</span>(<span class="bu">round</span>(curr_e<span class="op">*</span><span class="fl">1e3</span>))<span class="op">+</span><span class="st">' mV'</span>, color<span class="op">=</span>[<span class="dv">0</span>,<span class="dv">0</span>,ind<span class="op">/</span><span class="bu">len</span>(e_values)])</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>plt.xlim([<span class="op">-</span><span class="dv">100</span>, <span class="dv">135</span>])</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Membrane potential (mV)'</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Ionic current (pA)'</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Effect of reversal potential on ionic current'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>Text(0.5, 1.0, 'Effect of reversal potential on ionic current')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-8-output-2.png" width="604" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>As we shift the value of the equilibrium potential, the voltage at which the ionic current shifts from negative to positive shifts in tandem.</p>
<p>By itself, this circuit does not produce any interesting temporal dynamics or integrative abilities. To begin to capture those, we need to incorporate another detail about the electrical properties of the neuronal membrane.</p>
</section>
<section id="membrane-as-a-capacitor" class="level3">
<h3 class="anchored" data-anchor-id="membrane-as-a-capacitor">Membrane as a capacitor</h3>
<p>The neuron’s membrane is conceived of as a capacitor (see <a href="https://doi.org/10.1016/S0006-3495(00)76293-X">this paper</a> for more info). A capacitor is composed of an insulator sandwiched between two conductors, in our case the lipid membrane acts as the insulator since charge cannot cross it, and the extracellular and intracellular ionic solutions are the conductors. Since each charge puts out an electric field attracts the opposite charge and repels the same charge, and this field decays with distance from the charge, the thinner the insulator is the stronger charges on either side of it can influence each other. If positive charges build up on one side of the capacitor, then they will draw negative charges to build up on the opposite side. The ability of a capacitor to store charge is quantified by its capacitance:</p>
<p><span class="math display"> C = \frac{\epsilon\epsilon_{0}A}{d} </span></p>
<p>where <span class="math inline">\epsilon</span> is the dielectric constant of the insulation material, <span class="math inline">\epsilon_{0}</span> is the polarizability of free space, <span class="math inline">A</span> is the surface area of the capacitor, and <span class="math inline">d</span> is the thickness of the insulator. Capacitance is measured in the unit Farads (F). This equation tells us that to increase capacitance one should enlarge the surface area of the capacitor, allowing more space to accommodate charge, and shrink the thickness of the insulator, making it easier for charges on either side to interact.</p>
<p>What value does the capacitance take for neurons? Since all membranes are composed of a lipid bilayer, they do not differ in their material composition so their <span class="math inline">\epsilon</span> stays the same, and <span class="math inline">\epsilon_{0}</span> is a physical constant that does not change. The thickness of the neuronal membrane, <span class="math inline">d</span>, our insulator, is also consistent across neurons, with a value of ~9 nm (for comparison, that is about eleven thousand times thinner than the thickness of printer paper). But, since neurons can vary in size, <span class="math inline">A</span> varies greatly across neurons. So, we often use ‘specific capacitance’, which is the ratio between capacitance and area. The specific capacitance for neurons is generally around 1 𝜇F/cm<sup>2</sup>. If we approximate a neuron as a sphere, then its capacitance can be calculated using its radius to calculate the area of the sphere (<span class="math inline">A=4 \pi r^2</span>), and multiplying that by the 1 𝜇F/cm<sup>2</sup>. For instance, a neuron with a radius of 10 um has a capacitance of 12.5 pF.</p>
</section>
<section id="passive-electrical-model-of-the-membrane" class="level3">
<h3 class="anchored" data-anchor-id="passive-electrical-model-of-the-membrane">Passive electrical model of the membrane</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/MemBatResCap.png" class="img-fluid figure-img"></p>
<figcaption>membrane as capacitor</figcaption>
</figure>
</div>
<p>Expanding our electrical schematic we add the membrane capacitor in parallel with the resting potential battery and conductor. This is the <em>passive</em> electrical model of the membrane. Many classic phenomena of neural integration arise from the passive electrical behavior of its membrane.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/MemRest.png" class="img-fluid figure-img"></p>
<figcaption>membrane rest</figcaption>
</figure>
</div>
<p>The battery charges up the capacitor, forcing it to adopt a potential equal to the resting potential. Once it has reached this stable state, what if we were to artificially inject a current into the neuron? To calculate this, we can use a rule from electrical theory called Kirchoff’s current law (see <a href="https://en.wikipedia.org/wiki/Kirchhoff%27s_circuit_laws#Kirchhoff's_current_law" title="Wikipedia link">Kirchoff’s current law</a>). It states that the current flowing into a node of an electrical circuit must equal the current flowing out of it. We already have an equation (Ohm’s law) that describes the current produced by our ionic leak current, now we need to know how to calculate the current produced by the capacitor.</p>
<p>The relationship between current and voltage for a capacitor is described by the equation:</p>
<p><span class="math display"> I = C\frac{dV}{dt} \tag{2}</span></p>
<p>What this means is that the current produced across the capacitor is proportional to the change in voltage.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/MemCharging.png" class="img-fluid figure-img"></p>
<figcaption>membrane charging with resistance</figcaption>
</figure>
</div>
<p>The passive electrical circuit model is also known as an <em>RC circuit</em>, because it contains a resistor and capacitor. What is its behavior? When it is first put together, there is no voltage across the capacitor, so the battery will charge it up. However, the resistor places a limit on the current, meaning the capacitor will not fully charge instantly. To determine the trajectory the voltage will take, we can model this with an equation by combining equations 1 and 2 using Kirchoff’s current law. For the circuit above, this yields the equation: <span class="math display"> \begin{align}
    \notag
    0 &amp;= I_{rest} + I_{C} \\ \notag
    0 &amp;=g_{m}(V_{m}-E_{rest}) + C_{m}\frac{dV_{m}}{dt} \\ \notag
    -C\frac{dV_{m}}{dt}&amp;=g_{m}(V_{m}-E_{rest}) \\ \notag
    \frac{dV_{m}}{dt}&amp;=-\frac{g_{m}}{C}(V_{m}-E_{rest})
    \end{align}
</span></p>
<p>This is a differential equation that can be solved to give voltage as a function of time: <span class="math display"> V_{m}(t) = E_{rest}(1-e^{\frac{-t}{\frac{g_{m}}{C_{m}}}}) </span></p>
<p>Rewriting <span class="math inline">g_{m}</span>, as its inverse, referred to as membrane resistance, <span class="math inline">R_{m}</span>, we get the equation: <span class="math display"> V_{m}(t) = E_{rest}(1-e^{\frac{-t}{R_{m}C_{m}}}) \tag{3}</span></p>
<p>The product of <span class="math inline">R_{m}</span> and <span class="math inline">C_{m}</span> sets how fast the membrane charges. Larger it is, the slower the membrane capacitor will charge, and the smaller it is, the faster it charges. Given realistic values of <span class="math inline">R_{m}</span> and <span class="math inline">C_{m}</span>, what would be a reasonable time constant to expect from a neuron?</p>
<div id="437ccfa6" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate membrane resistance and capacitance</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>mem_cap <span class="op">=</span> <span class="fl">1e-6</span> <span class="co"># F/cm^2</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>cell_c <span class="op">=</span> mem_cap <span class="op">*</span> cell_area <span class="co"># F</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>cell_r <span class="op">=</span> mem_r <span class="op">/</span> cell_area <span class="co"># ohm</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>cell_tau <span class="op">=</span> cell_r <span class="op">*</span> cell_c <span class="co"># sec</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Membrane capacitance: </span><span class="sc">{:.0f}</span><span class="st"> pF'</span>.<span class="bu">format</span>(cell_c<span class="op">*</span><span class="fl">1e12</span>))</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Membrane resistance: </span><span class="sc">{:.0f}</span><span class="st"> MOhm'</span>.<span class="bu">format</span>(cell_r<span class="op">*</span><span class="fl">1e-6</span>))</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Membrane time constant: </span><span class="sc">{:.0f}</span><span class="st"> ms'</span>.<span class="bu">format</span>(cell_tau<span class="op">*</span><span class="fl">1e3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Membrane capacitance: 113 pF
Membrane resistance: 221 MOhm
Membrane time constant: 25 ms</code></pre>
</div>
</div>
<div id="060eb01c" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot examples of V changing over time for different RC time constants</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>tau_factors <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="fl">0.1</span>, <span class="dv">100</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ind, curr_factor <span class="kw">in</span> <span class="bu">enumerate</span>(tau_factors):</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    curr_tau <span class="op">=</span> cell_tau<span class="op">*</span>curr_factor</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    plt.plot(t<span class="op">*</span><span class="fl">1e3</span>, e_rest<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>np.exp(<span class="op">-</span>t<span class="op">/</span>curr_tau))<span class="op">*</span><span class="fl">1e3</span>, </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>             label<span class="op">=</span>curr_tau<span class="op">*</span><span class="fl">1e3</span>, color<span class="op">=</span>[<span class="dv">0</span>,<span class="dv">0</span>,ind<span class="op">/</span><span class="bu">len</span>(tau_factors)])</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    plt.text(t[<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span><span class="fl">1e3</span><span class="op">+</span><span class="dv">2</span>, e_rest<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>np.exp(<span class="op">-</span>t[<span class="op">-</span><span class="dv">1</span>]<span class="op">/</span>curr_tau))<span class="op">*</span><span class="fl">1e3</span>,</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>                <span class="bu">str</span>(<span class="bu">round</span>(curr_tau<span class="op">*</span><span class="fl">1e3</span>,<span class="dv">2</span>))<span class="op">+</span><span class="st">' ms'</span>, color<span class="op">=</span>[<span class="dv">0</span>,<span class="dv">0</span>,ind<span class="op">/</span><span class="bu">len</span>(tau_factors)])</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>plt.xlim([<span class="op">-</span><span class="dv">5</span>, <span class="dv">125</span>])</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Membrane potential (mV)'</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Effect of RC time constant on membrane potential charging'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>Text(0.5, 1.0, 'Effect of RC time constant on membrane potential charging')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-10-output-2.png" width="596" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>What this shows is that longer membrane time constants, <span class="math inline">\tau</span>, slow the rate of change in the membrane potential.</p>
</section>
<section id="creating-a-passive-neuron-model" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-passive-neuron-model">Creating a passive neuron model</h3>
<p>Equation 3 showed us the relationship between time and membrane potential at the moment the membrane capacitance was connected with the leak current. This is, of course, not realistic. Instead, neurons start at the resting potential and recieve occasional inputs that inject currents into the neuron. To capture this, we can use the following equation:</p>
<p><span class="math display"> \begin{align}
    \notag
    0 &amp;= I_{rest} + I_{C} + I_{in}\\ \notag
    0 &amp;=g_{m}(V_{m}-E_{rest}) + C_{m}\frac{dV_{m}}{dt} + I_{in}\\ \notag
    -C_{m}\frac{dV_{m}}{dt}&amp;=g_{m}(V_{m}-E_{rest}) + I_{in}\\ \notag
    \frac{dV_{m}}{dt}&amp;=-\frac{1}{C_{m}}({g_{m}}(V_{m}-E_{rest}) + I_{in})  \tag{4}
    \end{align}
</span></p>
<p>Since we know how the membrane voltage will change, <span class="math inline">\frac{dV_{m}}{dt}</span>, based on its present value, <span class="math inline">V_{m}</span>, and the current injected, <span class="math inline">I_{in}</span>, we can simulate its response. To do this, we will create a class, <code>PassiveNeuron</code>. This class will encapsulate the data and methods needed to simulate the passive properties of a neuron’s membrane.</p>
<div id="5fafd75b" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PassiveNeuron:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, v_rest<span class="op">=-</span><span class="dv">65</span>, c_m<span class="op">=</span><span class="dv">1</span>, r_m<span class="op">=</span><span class="dv">25</span>, radius<span class="op">=</span><span class="dv">30</span>):</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._vrest <span class="op">=</span> v_rest<span class="op">/</span><span class="dv">1000</span> <span class="co"># mV</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._cm <span class="op">=</span> c_m <span class="op">*</span> <span class="fl">1e-6</span> <span class="co"># uF/cm^2</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._rm <span class="op">=</span> r_m <span class="op">*</span> <span class="fl">1e3</span> <span class="co"># kOhm*cm^2</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._radius <span class="op">=</span> radius <span class="op">*</span> <span class="fl">1e-4</span> <span class="co"># cm</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._area <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> np.pi <span class="op">*</span> <span class="va">self</span>._radius<span class="op">**</span><span class="dv">2</span> <span class="co"># cm^2</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._c <span class="op">=</span> <span class="va">self</span>._cm <span class="op">*</span> <span class="va">self</span>._area <span class="co"># F  </span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._gleak <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="va">self</span>._rm <span class="op">/</span> <span class="va">self</span>._area) <span class="co"># S</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._vm <span class="op">=</span> <span class="va">self</span>._vrest</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._im <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._add <span class="op">=</span> <span class="dv">0</span> <span class="co"># holds additional current to deliver to the neuron</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._dt <span class="op">=</span> <span class="fl">0.0001</span> <span class="co"># sec</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_tau(<span class="va">self</span>):</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._cm <span class="op">*</span> <span class="va">self</span>._rm</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_input(<span class="va">self</span>, inp<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._add <span class="op">=</span> inp</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset_state(<span class="va">self</span>):</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._vm <span class="op">=</span> <span class="va">self</span>._vrest</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._im <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._add <span class="op">=</span> <span class="dv">0</span> <span class="co"># holds additional current to deliver to the neuron</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_state(<span class="va">self</span>):</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># return membrane potential in mV, membrane current in nA, and spike status</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._vm<span class="op">*</span><span class="fl">1e3</span>, <span class="va">self</span>._im<span class="op">*</span><span class="fl">1e9</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_t_vec(<span class="va">self</span>, dur <span class="op">=</span> <span class="fl">0.1</span>, dt <span class="op">=</span> <span class="fl">0.0001</span>):</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.arange(<span class="dv">0</span>, dur, dt)</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update(<span class="va">self</span>):</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># solve for transmembrane currents</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._im <span class="op">=</span> (<span class="va">self</span>._gleak <span class="op">*</span> (<span class="va">self</span>._vm <span class="op">-</span> <span class="va">self</span>._vrest)) <span class="op">+</span> <span class="va">self</span>._add</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># update membrane potential</span></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._vm <span class="op">=</span> <span class="va">self</span>._vm <span class="op">+</span> <span class="op">-</span>(<span class="va">self</span>._im <span class="op">/</span> <span class="va">self</span>._c) <span class="op">*</span> <span class="va">self</span>._dt</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run(<span class="va">self</span>, dur<span class="op">=</span><span class="fl">0.1</span>, dt<span class="op">=</span><span class="fl">0.0001</span>, inp<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.reset_state() <span class="co"># reset state</span></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># initialize arrays to store values</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> <span class="va">self</span>.get_t_vec(dur, dt) <span class="co"># time array</span></span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> np.zeros(<span class="bu">len</span>(t)) <span class="co"># voltage array</span></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> np.zeros(<span class="bu">len</span>(t)) <span class="co"># current array</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._dt <span class="op">=</span> dt <span class="co"># set time step</span></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># if input is scalar, make it an array</span></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(inp, (<span class="bu">int</span>, <span class="bu">float</span>)):</span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>            inp <span class="op">=</span> np.ones(<span class="bu">len</span>(t)) <span class="op">*</span> inp</span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>        <span class="co"># run simulation</span></span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ind, _ <span class="kw">in</span> <span class="bu">enumerate</span>(t):</span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.set_input(inp[ind]) <span class="co"># set input current</span></span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.update() <span class="co"># update membrane potential and current</span></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>            v[ind], i[ind] <span class="op">=</span> <span class="va">self</span>.get_state() <span class="co"># store values</span></span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v, i</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="516210e4" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a neuron with default parameters</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>pas_nrn <span class="op">=</span> PassiveNeuron()</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>sim_dur <span class="op">=</span> <span class="fl">0.2</span> <span class="co"># sec</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>sim_dt <span class="op">=</span> <span class="fl">0.0001</span> <span class="co"># sec</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>t_pts <span class="op">=</span> pas_nrn.get_t_vec(dur<span class="op">=</span>sim_dur, dt<span class="op">=</span>sim_dt)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a step current input</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> step_current(t, start<span class="op">=</span><span class="fl">0.025</span>, end<span class="op">=</span><span class="fl">0.125</span>, amp<span class="op">=-</span><span class="fl">1e-10</span>):</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    step <span class="op">=</span> np.zeros(<span class="bu">len</span>(t))</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    step[np.where((t<span class="op">&gt;=</span>start)<span class="op">&amp;</span>(t<span class="op">&lt;</span>end))[<span class="dv">0</span>]] <span class="op">=</span> amp</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> step</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>in_step <span class="op">=</span> step_current(t_pts)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>pas_v, pas_i <span class="op">=</span> pas_nrn.run(dur<span class="op">=</span>sim_dur, dt<span class="op">=</span>sim_dt, inp<span class="op">=</span>in_step)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_sim(t, v, i, inp, title<span class="op">=</span><span class="st">''</span>):</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    plt.plot(t<span class="op">*</span><span class="fl">1e3</span>, v, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    plt.yticks(color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'mV'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    plt.grid()</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Membrane potential'</span>)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    plt.plot(t<span class="op">*</span><span class="fl">1e3</span>, i, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    plt.yticks(color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'nA'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Membrane current'</span>)</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    plt.grid()</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">3</span>)</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    plt.plot(t<span class="op">*</span><span class="fl">1e3</span>, inp<span class="op">*</span><span class="fl">1e9</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    plt.yticks(color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'nA'</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Input current'</span>)</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>    plt.grid()</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(title)</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout(rect<span class="op">=</span>[<span class="dv">0</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="fl">0.95</span>])</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>plot_sim(t_pts, pas_v, pas_i, in_step, title<span class="op">=</span><span class="st">'Passive neuron'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-12-output-1.png" width="654" height="461" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>When we inject a current step into the neuron, the membrane begins to depolarize from its resting potential towards a new voltage. This is accompanied by an strong current crossing the membrane, which reflects the injected current charging up the membrane capacitance. As the membrane capacitance charges up, this current decays because it is offset by the leak current, which flows in the opposite direction of the injected current. The leak current is driven by the difference between <span class="math inline">V_{m}</span> and <span class="math inline">E_{r}</span>. For the leak current to balance out the injected current, the membrane potential must reach:</p>
<p><span class="math display"> V_{m} = \frac{I_{in}}{g_{leak}}+E_{r}</span></p>
<p>Thus, a increasing <span class="math inline">g_{leak}</span> (or lowering membrane resistance, <span class="math inline">R_{m}</span>), lowers the change in membrane potential to an injected current. We can see this here:</p>
<div id="6304dab9" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>pas_nrn_hig <span class="op">=</span> PassiveNeuron(v_rest<span class="op">=-</span><span class="dv">65</span>, c_m<span class="op">=</span><span class="dv">1</span>, r_m<span class="op">=</span><span class="dv">5</span>, radius<span class="op">=</span><span class="dv">30</span>) <span class="co"># we lowered the membrane resistance, r_m, which increased the membrane conductance, g_m</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>pas_v_hig, pas_i_hig <span class="op">=</span> pas_nrn_hig.run(dur<span class="op">=</span>sim_dur, dt<span class="op">=</span>sim_dt, inp<span class="op">=</span>in_step)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>plot_sim(t_pts, pas_v_hig, pas_i_hig, in_step, title<span class="op">=</span><span class="st">'Passive neuron with higher $g_</span><span class="sc">{leak}</span><span class="st">$'</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Get values of g_leak for each model</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'g_leak for regular model: </span><span class="sc">{:.0f}</span><span class="st"> nS'</span>.<span class="bu">format</span>(pas_nrn._gleak<span class="op">*</span><span class="fl">1e9</span>))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'g_leak for high g model: </span><span class="sc">{:.0f}</span><span class="st"> nS'</span>.<span class="bu">format</span>(pas_nrn_hig._gleak<span class="op">*</span><span class="fl">1e9</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>g_leak for regular model: 5 nS
g_leak for high g model: 23 nS</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-13-output-2.png" width="662" height="461" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Increasing <span class="math inline">g_{leak}</span> lowered the change in membrane potential from around 12 mV to 3 mV. Notice also that <span class="math inline">V_{m}</span> changes much faster now, because the membrane time constant is shorter.</p>
<p>Increasing the amount of current we inject also increases the change in <span class="math inline">V_{m}</span>.</p>
<div id="50c4f17e" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>in_step <span class="op">=</span> step_current(t_pts, amp<span class="op">=-</span><span class="fl">2e-10</span>) <span class="co"># increase input current by 2x</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>pas_v, pas_i <span class="op">=</span> pas_nrn.run(dur<span class="op">=</span>sim_dur, dt<span class="op">=</span>sim_dt, inp<span class="op">=</span>in_step)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>plot_sim(t_pts, pas_v, pas_i, in_step, title<span class="op">=</span><span class="st">'Passive neuron with $2xI_</span><span class="sc">{in}</span><span class="st">$'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-14-output-1.png" width="662" height="461" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>So far we have been giving negative current injections, which pushes the membrane towards positive values. If <span class="math inline">V_{m}</span> moves towards positive values, we say it is <em>depolarizing</em>. By contrast, if it is pushed towards negative values, it is <em>hyperpolarizing</em>. To hyperpolarize, we inject a positive current.</p>
<div id="e7b444d8" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># hyperpolarize the membrane potential</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>in_step <span class="op">=</span> step_current(t_pts, amp<span class="op">=</span><span class="fl">1e-10</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>pas_v, pas_i <span class="op">=</span> pas_nrn.run(dur<span class="op">=</span>sim_dur, dt<span class="op">=</span>sim_dt, inp<span class="op">=</span>in_step)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>plot_sim(t_pts, pas_v, pas_i, in_step, title<span class="op">=</span><span class="st">'Passive neuron with being hyperpolarized'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-15-output-1.png" width="662" height="461" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>All the activity we have seen so far is slow changes in membrane potential. These are not conveyed to downstream neurons. Instead, neurons have to fire <em>action potentials</em> to influence their neighbors.</p>
</section>
<section id="action-potentials" class="level3">
<h3 class="anchored" data-anchor-id="action-potentials">Action potentials</h3>
<p>Action potentials are large positive excursions of the membrane potential. They last less than 2 ms and propagate from the cell body down the axon, eventually triggering release of neurotransmitter at the synapse. They are the principal output of neurons and, for the most part, the only information about the state of a neuron that is conveyed to the rest of the network.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/MemAPGeneration.png" class="img-fluid figure-img"></p>
<figcaption>membrane with action potential</figcaption>
</figure>
</div>
<p>To generate an action potential, a neuron is first depolarized to a sufficient level that starts to open voltage-gated Na<sup>+</sup> ion channels. Recalling that Na<sup>+</sup> has a positive reversal potential, their opening will depolarize the membrane voltage. This depolarization recruits more voltage-gated Na<sup>+</sup> ion channels, reinforcing the depolarization and driving the membrane potential towards the Na<sup>+</sup> reversal potential (~40 mV). Then, these channels begin to <em>inactivate</em>, closing and bringing the membrane back towards its resting potential. This fall back towards rest is accelerated by voltage-dependent K<sup>+</sup> channels, which open during the depolarization of the action potential and drive the membrane towards the K<sup>+</sup> reversal potential (~-70 mV). During this period, the neuron enters a <em>refractory period</em>. The first phase of this is absolute, where the neuron cannot fire an action potential due to the inactivation of Na<sup>+</sup> channels. This is followed by a relative period, where the an action potential can be generated again, but the K<sup>+</sup> current counteracts this, effectively increasing the amount of current required to cross the voltage threshold.</p>
<p>The voltage-gated Na<sup>+</sup> and K<sup>+</sup> currents are similar in principal to the leak current discussed earlier. They are a battery, the equilibrium potential of Na<sup>+</sup> or K<sup>+</sup>, in series with a conductor. The difference is that the conductor depends on <span class="math inline">V_{m}</span> and time. We can expand our electrical model of the passive neuron to incorporate these voltage-gated currents, thus allowing us to model action potentials.</p>
<p>The equation that captures this is:</p>
<p><span class="math display"> \frac{dV_{m}}{dt}=-\frac{1}{C}(g_{m}(V_{m}-E_{rest}) + g_{Na_{V,t}}(V_{m}-E_{Na}) + g_{K_{V,t}}(V_{m}-E_{K}) + I_{in}) \tag{5} </span></p>
<p>Here <span class="math inline">g_{Na_{V,t}}</span> is the voltage and time dependent conductance for Na<sup>+</sup>, and similar for <span class="math inline">g_{K_{V,t}}</span>. The driving force for those currents depends on how far <span class="math inline">V_{m}</span> is from the respective equilibrium potentials of those ions. In essence, increasing <span class="math inline">g_{Na_{V,t}}</span> or <span class="math inline">g_{K_{V,t}}</span> pulls <span class="math inline">V_{m}</span> towards the corresponding equilibrium potential.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
A note about coding and neuronal firing
</div>
</div>
<div class="callout-body-container callout-body">
<p>Action potentials are often described as all-or-none events. Either they occur or they do not, and when they do, they tend to always have the same strength and duration. Since they are stereotyped, it is thought that they convey information by their timing. Several different terms are often used to describe the codes offered by action potentials. A <em>time code</em> is when the exact time of an action potential indicates the occurrence of some event (whether it be environmental or behavioral). This is often counterposed to a <em>rate code</em>, where the informational signal is how many action potentials occurred in some short amount of time, with a higher rate indicating a ‘stronger’ signal. Alternatively, a <em>population code</em> uses the set of neurons firing action potentials at any given moment to encode information. Different ensembles of activated neurons signal different events.</p>
</div>
</div>
</section>
<section id="creating-a-simplified-active-neuron-model" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-simplified-active-neuron-model">Creating a simplified active neuron model</h3>
<p>When we include voltage-gated ion channels in a model neuron, it goes from being a passive model to an <em>active model</em>. We can build upon our existing <code>PassiveNeuron</code> class to create an <code>ActiveNeuron</code> class that generates an approximation of action potentials. To do this, we will add the voltage-dependent Na<sup>+</sup> and K<sup>+</sup> currents. This requires specifying the equilibrium potential for those ions, a <span class="math inline">V_{m}</span> threshold that initiates the action potential, and designing voltage- and time-dependent conductances to gate the active currents.</p>
<div id="3a7affa9" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create active neuron class that inheriting from the passive neuron model</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ActiveNeuron(PassiveNeuron):</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, v_thresh<span class="op">=-</span><span class="dv">50</span>, ena<span class="op">=</span><span class="dv">50</span>, ek<span class="op">=-</span><span class="dv">90</span>, gna<span class="op">=</span><span class="fl">8e-8</span>, gk<span class="op">=</span><span class="fl">4e-8</span>, <span class="op">**</span>kwargs):</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(<span class="op">**</span>kwargs) <span class="co"># allows us to pass arguments for the passive properties of the neuron</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._vthresh <span class="op">=</span> v_thresh <span class="op">/</span> <span class="dv">1000</span> <span class="co"># mV</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._ena <span class="op">=</span> ena <span class="op">/</span> <span class="dv">1000</span> <span class="co"># mV</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._gna <span class="op">=</span> gna <span class="co"># S</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._ek <span class="op">=</span> ek <span class="op">/</span> <span class="dv">1000</span> <span class="co"># mV</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._gk <span class="op">=</span> gk <span class="co"># S</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._spk_timer <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._spk <span class="op">=</span> <span class="va">False</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset_state(<span class="va">self</span>):</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().reset_state()</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._spk_timer <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._spk <span class="op">=</span> <span class="va">False</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gen_ap(<span class="va">self</span>):</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># action potential mechanism</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="va">self</span>._vm <span class="op">&gt;</span> <span class="va">self</span>._vthresh) <span class="op">&amp;</span> (<span class="va">self</span>._spk_timer <span class="op">&lt;=</span> <span class="dv">0</span>):</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._spk_timer <span class="op">=</span> <span class="fl">0.004</span> <span class="co"># start countdown timer for duration of action potential</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._spk <span class="op">=</span> <span class="va">True</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>._spk_timer <span class="op">&gt;</span> <span class="fl">0.003</span>: <span class="co"># open up sodium conductance for first 1 ms</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._add <span class="op">=</span> <span class="va">self</span>._add <span class="op">+</span> <span class="va">self</span>._gna <span class="op">*</span> (<span class="va">self</span>._vm <span class="op">-</span> <span class="va">self</span>._ena)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._spk <span class="op">=</span> <span class="va">False</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._spk_timer <span class="op">-=</span> <span class="va">self</span>._dt</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>._spk_timer <span class="op">&gt;</span> <span class="dv">0</span>: <span class="co"># open up potassium conductance for next 3 ms</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._add <span class="op">=</span> <span class="va">self</span>._add <span class="op">+</span> <span class="va">self</span>._gk <span class="op">*</span> (<span class="va">self</span>._vm <span class="op">-</span> <span class="va">self</span>._ek)</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._spk <span class="op">=</span> <span class="va">False</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._spk_timer <span class="op">-=</span> <span class="va">self</span>._dt</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run(<span class="va">self</span>, dur<span class="op">=</span><span class="fl">0.1</span>, dt<span class="op">=</span><span class="fl">0.0001</span>, inp<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.reset_state() <span class="co"># reset state</span></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># initialize arrays to store values</span></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> <span class="va">self</span>.get_t_vec(dur, dt) <span class="co"># time array</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> np.zeros(<span class="bu">len</span>(t)) <span class="co"># voltage array</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> np.zeros(<span class="bu">len</span>(t)) <span class="co"># current array</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._dt <span class="op">=</span> dt <span class="co"># set time step</span></span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># if input is scalar, make it an array</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(inp, (<span class="bu">int</span>, <span class="bu">float</span>)):</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>            inp <span class="op">=</span> np.ones(<span class="bu">len</span>(t)) <span class="op">*</span> inp</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># run simulation</span></span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ind, _ <span class="kw">in</span> <span class="bu">enumerate</span>(t):</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.set_input(inp[ind]) <span class="co"># set input current</span></span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.gen_ap() <span class="co"># generate action potential &lt;-- NEW</span></span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.update() <span class="co"># update membrane potential and current</span></span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>            v[ind], i[ind] <span class="op">=</span> <span class="va">self</span>.get_state() <span class="co"># store values</span></span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v, i</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2a68175e" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an active neuron and deliver a subthreshold and over threshold current</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>act_nrn <span class="op">=</span> ActiveNeuron()</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>sim_dur_act <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>t_pts <span class="op">=</span> act_nrn.get_t_vec(dur<span class="op">=</span>sim_dur_act, dt<span class="op">=</span>sim_dt)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>in_step_act <span class="op">=</span> step_current(t_pts, start<span class="op">=</span><span class="fl">0.1</span>, end<span class="op">=</span><span class="fl">0.2</span>, amp<span class="op">=-</span><span class="fl">5e-11</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>                step_current(t_pts, start<span class="op">=</span><span class="fl">0.3</span>, end<span class="op">=</span><span class="fl">0.4</span>, amp<span class="op">=-</span><span class="fl">1e-10</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>act_v, act_i <span class="op">=</span> act_nrn.run(dur<span class="op">=</span>sim_dur_act, dt<span class="op">=</span>sim_dt, inp<span class="op">=</span>in_step_act)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>plot_sim(t_pts, act_v, act_i, in_step_act, title<span class="op">=</span><span class="st">'Active neuron with subthreshold and overthreshold current'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-17-output-1.png" width="654" height="461" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>For this model we set the action potential threshold to -50 mV, and if we depolarize below that level we get the passive subthreshold depolarization that we saw in the previous model. If the current step is increased, then the membrane depolarizes passively until the threshold is reached, at which point an action potential is triggered. The action potential voltage approaches the equilibrium potential for Na<sup>+</sup>, and then quickly reverses towards the equilibrium potential of K<sup>+</sup>. The transmembrane currents associated with the action potential are substantially greater than those from the subthreshold depolarization. This is due to the very high conductance of the voltage-gated channels (Na<sup>+</sup> channel: 80 nS vs.&nbsp;<span class="math inline">g_{leak}</span>: 5 nS).</p>
<p>More than one action potential is emitted during the 100 ms over-threshold current step. The time between action potentials depends on two factors. First is the refractory period, with a stronger or longer refractory period delaying the time to the next action potential. The other is the strength of the injected current, with a stronger current able to overcome the refractory effect and elicit another action potential sooner. We can explore the effect of current strength by delivering a series of current pulses to our model with increasing amplitudes.</p>
<div id="f6b8b46f" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Examine how firing rate varies with curent injected</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>act_nrn <span class="op">=</span> ActiveNeuron()</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>sim_dur_act <span class="op">=</span> <span class="fl">1.1</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>t_pts <span class="op">=</span> act_nrn.get_t_vec(dur<span class="op">=</span>sim_dur_act, dt<span class="op">=</span>sim_dt)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="co"># create a series of step currents with increasing amplitudes</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>in_step_act <span class="op">=</span> step_current(t_pts, start<span class="op">=</span><span class="fl">0.1</span>, end<span class="op">=</span><span class="fl">0.2</span>, amp<span class="op">=-</span><span class="fl">5e-11</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>                step_current(t_pts, start<span class="op">=</span><span class="fl">0.3</span>, end<span class="op">=</span><span class="fl">0.4</span>, amp<span class="op">=-</span><span class="fl">8e-11</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>                step_current(t_pts, start<span class="op">=</span><span class="fl">0.5</span>, end<span class="op">=</span><span class="fl">0.6</span>, amp<span class="op">=-</span><span class="fl">1.6e-10</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>                step_current(t_pts, start<span class="op">=</span><span class="fl">0.7</span>, end<span class="op">=</span><span class="fl">0.8</span>, amp<span class="op">=-</span><span class="fl">2.4e-10</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>                step_current(t_pts, start<span class="op">=</span><span class="fl">0.9</span>, end<span class="op">=</span><span class="fl">1.0</span>, amp<span class="op">=-</span><span class="fl">3.2e-10</span>)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>act_v, act_i <span class="op">=</span> act_nrn.run(dur<span class="op">=</span>sim_dur_act, dt<span class="op">=</span>sim_dt, inp<span class="op">=</span>in_step_act)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>plot_sim(t_pts, act_v, act_i, in_step_act, title<span class="op">=</span><span class="st">'Reponse to increasing current steps'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-18-output-1.png" width="662" height="461" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Increasing the current step amplitude increased the number of action potentials emitted, and shortened the time between them. Thus, the rate of action potential generation is proportional to the excitatory drive the neuron receives.</p>
<p>However, it is important to remember that neurons are not normally driven by artificial current steps. Instead, they have synapses that are driven by the action potentials from other neurons.</p>
</section>
<section id="synapses" class="level3">
<h3 class="anchored" data-anchor-id="synapses">Synapses</h3>
<p>Since neurons form networks that share electrical signals, there must be a means for these signals to be passed from one neuron to another. This exchange occurs at synapses, where the axon from the <em>presynaptic</em> neuron forms a terminal on the dendrite of the <em>postsynaptic</em> neuron. Between them is a narrow space called the <em>synaptic cleft</em>, where neurotransmitters released by the presynaptic terminal crosses to binds to ion channels on the postsynaptic neuron. When the neurotransmitter binds it opens an ion channel, which allows a current composed of the ions that channel is permeable to to flow. Channels that are found at excitatory synapses, which drive the membrane potential towards positive values (depolarize), tend to be permeable positive ions, Na<sup>+</sup>, K<sup>+</sup>, and Ca<sup>2+</sup>. Inhibitory synapses rely on ion channels selective for the negative Cl<sup>-</sup> ion and can counteract the excitatory depolarization.</p>
<p>Cortical neurons are normally bombarded by an ongoing stream of excitatory and inhibitory synaptic activity. Usually these are balanced, so that the membrane potential shows only small changes in its level. However, if the excitatory synaptic drive overwhelms the inhibition it can push the membrane potential towards positive values and potentially trigger an action potential.</p>
<p>The ion channels that support synaptic transmission can be incorporated in our circuit model as just another branch, with an equilibrium potential reflecting their ionic permeability and a conductance that depends on number of open ion channels.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/MemBatResCapActSyn.png" class="img-fluid figure-img"></p>
<figcaption>Membrane with synapse</figcaption>
</figure>
</div>
<p>As for the leak and action potential related currents, the ionic current arising from synaptic transmission has the form: <span class="math display"> I_{syn} = g_{syn}r(V_{m}-E_{syn})</span></p>
<p>Here <span class="math inline">g_{Syn}</span> is the total possible conductance, and <span class="math inline">r</span> is the proportion of synaptic ion channels that are open. This depends on the presence of neurotransmitter in the synaptic cleft and time, and can be modeled as a reaction system, with separate rates describing the binding and dissociating of neurotransmitter to the receptor.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Modeling a synaptic current
</div>
</div>
<div class="callout-body-container callout-body">
<p>The shape of the ionic current arising from activating a synapse is described as having an <span class="math inline">\alpha</span>- or double exponential shape. Our passive neuron model has a single exponential shape: there is only one time constant, <span class="math inline">\tau</span>, that describes the timing of its rise and fall in response to a current input. For a double exponential, there are two time constants, one for the rise and a different one for the fall. The time constant for the rising phase is faster than that for the falling phase, leading to a skewed response. The differential equation that captures this is:</p>
<p><span class="math display"> \frac{dr}{dt} = \alpha[T]r - \beta(1-r) </span></p>
<p>The equation states that the change in the proportion of open ion channels, <span class="math inline">r</span>, increases at a rate <span class="math inline">\alpha</span> when neurotransmitter, <span class="math inline">[T]</span>, is present in the synapse. When neurotransmitter is absent from the synapse, <span class="math inline">r</span> then decreases at the rate of <span class="math inline">\beta</span>. (For more details, see <a href="https://pubmed.ncbi.nlm.nih.gov/8792231/">Destexhe, Mainen &amp; Sejnowski 1994</a>).</p>
</div>
</div>
<p>We can incorporate synapses into our active model to explore they affect the membrane potential and drive action potentials.</p>
<div id="7fce4048" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create an active neuron with synapse class that inherits from the active neuron model</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SynapticNeuron(ActiveNeuron):</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, esyn<span class="op">=</span><span class="dv">50</span>, gsyn<span class="op">=</span><span class="fl">5e-9</span>, asyn<span class="op">=</span><span class="dv">900</span>, bsyn<span class="op">=</span><span class="dv">500</span>, tdur<span class="op">=</span><span class="dv">3</span>, <span class="op">**</span>kwargs):</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(<span class="op">**</span>kwargs) <span class="co"># allows us to pass arguments for the passive properties of the neuron</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._esyn <span class="op">=</span> esyn <span class="op">/</span> <span class="dv">1000</span> <span class="co"># mV</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._gsyn <span class="op">=</span> gsyn <span class="co"># S</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._asyn <span class="op">=</span> asyn </span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._bsyn <span class="op">=</span> bsyn</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._tdur <span class="op">=</span> tdur <span class="op">/</span> <span class="dv">1000</span> <span class="co"># ms, duration of transmitter release</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._syn_timer <span class="op">=</span> <span class="dv">0</span> <span class="co"># timer for transmitter release</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._r <span class="op">=</span> <span class="dv">0</span> <span class="co"># fraction of open channels</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset_state(<span class="va">self</span>):</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().reset_state()</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._syn_timer <span class="op">=</span> <span class="dv">0</span> <span class="co"># timer for transmitter release</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._r <span class="op">=</span> <span class="dv">0</span> <span class="co"># fraction of open channels</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gen_syn(<span class="va">self</span>, prespk<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># synaptic mechanism</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> prespk:</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._syn_timer <span class="op">=</span> <span class="va">self</span>._tdur</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>._syn_timer <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._syn_timer <span class="op">-=</span> <span class="va">self</span>._dt</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># update fraction of open channels</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._r <span class="op">=</span> <span class="va">self</span>._r <span class="op">+</span> <span class="va">self</span>._dt <span class="op">*</span> ((<span class="va">self</span>._asyn <span class="op">*</span> (<span class="va">self</span>._syn_timer<span class="op">&gt;</span><span class="dv">0</span>) <span class="op">*</span> (<span class="dv">1</span><span class="op">-</span><span class="va">self</span>._r)) <span class="op">\</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>                                        <span class="op">-</span> (<span class="va">self</span>._bsyn <span class="op">*</span> (<span class="va">self</span>._r)))</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># add synaptic current</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._add <span class="op">=</span> <span class="va">self</span>._add <span class="op">+</span> <span class="va">self</span>._gsyn <span class="op">*</span> <span class="va">self</span>._r <span class="op">*</span> (<span class="va">self</span>._vm <span class="op">-</span> <span class="va">self</span>._esyn)</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run(<span class="va">self</span>, dur<span class="op">=</span><span class="fl">0.1</span>, dt<span class="op">=</span><span class="fl">0.0001</span>, inp<span class="op">=</span><span class="dv">0</span>, prespk<span class="op">=</span><span class="va">False</span>): <span class="co"># added prespk to drive synapse</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.reset_state() <span class="co"># reset state</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># initialize arrays to store values</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> <span class="va">self</span>.get_t_vec(dur, dt) <span class="co"># time array</span></span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> np.zeros(<span class="bu">len</span>(t)) <span class="co"># voltage array</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> np.zeros(<span class="bu">len</span>(t)) <span class="co"># current array</span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._dt <span class="op">=</span> dt <span class="co"># set time step</span></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># if input is scalar, make it an array</span></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(inp, (<span class="bu">int</span>, <span class="bu">float</span>)):</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>            inp <span class="op">=</span> np.ones(<span class="bu">len</span>(t)) <span class="op">*</span> inp</span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(prespk, (<span class="bu">bool</span>, <span class="bu">int</span>, <span class="bu">float</span>)):</span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>            prespk <span class="op">=</span> np.ones(<span class="bu">len</span>(t)) <span class="op">*</span> prespk</span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># run simulation</span></span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ind, _ <span class="kw">in</span> <span class="bu">enumerate</span>(t):</span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.set_input(inp[ind]) <span class="co"># set input current</span></span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.gen_syn(prespk[ind]) <span class="co"># generate synaptic response &lt;-- NEW</span></span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.gen_ap() <span class="co"># generate action potential</span></span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.update() <span class="co"># update membrane potential and current</span></span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>            v[ind], i[ind] <span class="op">=</span> <span class="va">self</span>.get_state() <span class="co"># store values</span></span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v, i</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="8ffc5f52" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># MODIFY PLOTTING CODE HERE</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_sim_prespk(t, v, i, inp, spk, title<span class="op">=</span><span class="st">''</span>):</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ensure neuron inputs have same length as time vector</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(inp, (<span class="bu">int</span>, <span class="bu">float</span>)):</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        inp <span class="op">=</span> np.ones(<span class="bu">len</span>(t)) <span class="op">*</span> inp</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(spk, (<span class="bu">bool</span>, <span class="bu">int</span>, <span class="bu">float</span>)):</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>        spk <span class="op">=</span> np.zeros(<span class="bu">len</span>(t))</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    plt.plot(t<span class="op">*</span><span class="fl">1e3</span>, v, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    plt.vlines(t[spk<span class="op">==</span><span class="dv">1</span>]<span class="op">*</span><span class="fl">1e3</span>, plt.ylim()[<span class="dv">0</span>], plt.ylim()[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    plt.yticks(color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'mV'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    plt.grid()</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Membrane potential'</span>)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    plt.plot(t<span class="op">*</span><span class="fl">1e3</span>, i, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    plt.vlines(t[spk<span class="op">==</span><span class="dv">1</span>]<span class="op">*</span><span class="fl">1e3</span>, plt.ylim()[<span class="dv">0</span>], plt.ylim()[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    plt.yticks(color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'nA'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Membrane current'</span>)</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>    plt.grid()</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(title)</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout(rect<span class="op">=</span>[<span class="dv">0</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="fl">0.95</span>])</span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Function for generating spike trains</span></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spk_train(t, spk_times<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>    spk_times <span class="op">=</span> np.array([spk_times]) <span class="co"># ensures spk_times is a numpy array</span></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>    spk <span class="op">=</span> np.zeros(<span class="bu">len</span>(t))</span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>    spk[np.<span class="bu">round</span>(spk_times <span class="op">/</span> sim_dt).astype(<span class="bu">int</span>)] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> spk</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="8e9e62d1" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># examine response to a single presynaptic spike</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>syn_nrn <span class="op">=</span> SynapticNeuron()</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>sim_dur_syn <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>t_pts <span class="op">=</span> syn_nrn.get_t_vec(dur<span class="op">=</span>sim_dur_syn, dt<span class="op">=</span>sim_dt)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>in_prespk <span class="op">=</span> spk_train(t_pts, [<span class="fl">0.05</span>])</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>syn_v, syn_i <span class="op">=</span> syn_nrn.run(dur<span class="op">=</span>sim_dur_syn, dt<span class="op">=</span>sim_dt, inp<span class="op">=</span><span class="dv">0</span>, prespk<span class="op">=</span>in_prespk)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>plot_sim_prespk(t_pts, syn_v, syn_i, <span class="dv">0</span>, in_prespk, title<span class="op">=</span><span class="st">'Synaptic response to a single presynaptic spike'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-21-output-1.png" width="654" height="461" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Activating the synapse at 50 ms leads to a rapid negative current that charges the membrane capacitance and depolarizes <span class="math inline">V_{m}</span>. This is soon followed by a decay in the synaptic current, as the proportion of synaptic ion channels that were open shrinks. Within ~10 ms the synaptic current is finished, and replaced by a positive leak current, which is the membrane returning to its resting potential. The rate of this return to rest is determined by the membrane time constant.</p>
<p>A single synaptic input is usually insufficient to drive an action potential. Typically multiple synaptic events have to be combined in close temporal proximity. We can explore this by delivering two presynaptic spikes and varying the time between them.</p>
<div id="c77452a3" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># delivery multiple presynaptic spikes with varying inter-spike intervals</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>sim_dur_syn <span class="op">=</span> <span class="fl">1.1</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>t_pts <span class="op">=</span> syn_nrn.get_t_vec(dur<span class="op">=</span>sim_dur_syn, dt<span class="op">=</span>sim_dt)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>in_prespk <span class="op">=</span> spk_train(t_pts, [<span class="fl">0.1</span>, <span class="fl">0.15</span>, <span class="fl">0.4</span>, <span class="fl">0.425</span>, <span class="fl">0.7</span>, <span class="fl">0.7125</span>, <span class="fl">1.0</span>, <span class="fl">1.00625</span>])</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>syn_v, syn_i <span class="op">=</span> syn_nrn.run(dur<span class="op">=</span>sim_dur_syn, dt<span class="op">=</span>sim_dt, inp<span class="op">=</span><span class="dv">0</span>, prespk<span class="op">=</span>in_prespk)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>plot_sim_prespk(t_pts, syn_v, syn_i, <span class="dv">0</span>, in_prespk, title<span class="op">=</span><span class="st">'Synaptic response to multiple presynaptic spikes'</span>)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>plt.gcf().set_size_inches((<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>plt.gcf().axes[<span class="dv">0</span>].axhline(syn_nrn._vthresh<span class="op">*</span><span class="fl">1e3</span>, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-22-output-1.png" width="1079" height="545" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The dashed line for the membrane potential plot is the action potential threshold. A single synaptic response is not sufficient to cross this threshold. If two are delivered, they must be close enough together, less than 25 ms between them, to trigger an action potential. Note also that making them closer does not increase the number of action potentials, only one is generated. To elicit multiple action potentials would require a sustained train of presynaptic spikes, such as below:</p>
<div id="4c964002" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># deliver a train of presynaptic spikes at 40 hz</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>sim_dur_syn <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>t_pts <span class="op">=</span> syn_nrn.get_t_vec(dur<span class="op">=</span>sim_dur_syn, dt<span class="op">=</span>sim_dt)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>in_prespk <span class="op">=</span> spk_train(t_pts, np.arange(<span class="fl">0.05</span>, <span class="fl">0.4</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">40</span>))</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>syn_v, syn_i <span class="op">=</span> syn_nrn.run(dur<span class="op">=</span>sim_dur_syn, dt<span class="op">=</span>sim_dt, inp<span class="op">=</span><span class="dv">0</span>, prespk<span class="op">=</span>in_prespk)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>plot_sim_prespk(t_pts, syn_v, syn_i, <span class="dv">0</span>, in_prespk, title<span class="op">=</span><span class="st">'Synaptic response to a 40 Hz spike train'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-23-output-1.png" width="658" height="461" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Delivering a train of presynaptic spikes at 40 Hz elicits a steady stream of action potentials in the postsynaptic neuron. Not every presynaptic spike elicits an action potential, instead they have to summate. In this case, it took 3 presynaptic spikes to elicit the first action potential, and subsequently every 2 spikes drove an action potential.</p>
</section>
</section>
<section id="detecting-the-activity-of-neurons" class="level2">
<h2 class="anchored" data-anchor-id="detecting-the-activity-of-neurons">Detecting the activity of neurons</h2>
<p>So far, we have been tracking neural activity by measuring the voltage and currents across the membrane. Experimentally, this is done using fine glass pipettes that are inserted into or make a hole in single neurons. This approach, known as <em>intracellular</em> or <em>whole-cell patch recording</em>, is not practical in humans, and exceptionally difficult in awake behaving animals. Instead, we typically use metal electrodes that do not need to be in direct contact with the neurons whose activity we want to detect. These electrodes pick up weak electrical signals emanating from nearby neurons, a technique referred to as <em>extracellular recording</em>. How does this work?</p>
<section id="physics-of-extracellular-potentials" class="level3">
<h3 class="anchored" data-anchor-id="physics-of-extracellular-potentials">Physics of extracellular potentials</h3>
<p>As we discussed above, the currents flowing across the membrane are composed of ions. Each ion has a charge, and charge produces an electric field that exerts a force on other charges. The force required move a charge through an electric field can be picked up as a potential on an electrode. Since the neuronal lipid membrane is an insulator, our electrode can only pick up the movement of charges across the membrane. If positive charges flow into the neuron, that is a net negative of charge on the outside an a negative potential results. If positive charges flow out of the neuron, that is a negative positive of charge on the outside, causing a positive potential.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Rall1962.png" class="img-fluid figure-img" width="441"></p>
<figcaption>Extracellular field of a cat motor neuron firing an action potential (numbers are in millivolts). From <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC1366481/?page=1">Rall 1962</a>.</figcaption>
</figure>
</div>
<p>Thus, the currents flowing through the membrane during synaptic barrages or action potentials can be detected by nearby electrodes. Fortunately for us, these transmembrane currents are so weak and so slow that we can use a simple equation to describe their influence on the voltage picked up by a nearby electrode. This is given by the equation:</p>
<p><span class="math display"> V = \frac{1}{4\pi\sigma}\frac{I}{d} </span></p>
<p>Here <span class="math inline">\sigma</span> is the conductivity of neural tissue, <span class="math inline">I</span> is a transmembrane current, and <span class="math inline">d</span> is the distance between the electrode and the current. A simplifying assumption we make when using this equation is that the the conductivity of the brain is homogeneous (sometimes referred to as being Ohmic). A few trends are clear from this equation. The influence that a transmembrane current has on an electrode will only depend on the the distance the electrode has from the current, and the current’s sign and magnitude. The further a current is from the electrode, the weaker it gets, with the greatest fall off happening at short distances. If a current is flowing into the neuron (excitatory), then it will produce a negative voltage at the electrode, while a current flowing out of the neuron (inhibitory) produces a positive voltage. The magnitude of the voltage signal will be linearly proportional to the voltage, e.g.&nbsp;doubling the current will double the voltage.</p>
<p>There are multiple current sources in the brain. Every open ion channel is a potential current source and these carpet the entire neuronal membrane. To capture their collective influence on a recording electrode, we can treat each as producing their own voltage and add them together.</p>
<p><span class="math display"> V = \frac{1}{4\pi\sigma}\sum_{i=0}^{n}\frac{I_i}{d_e - d_i} \tag{6}</span></p>
<p>In this equation we sum the resulting voltages from all currents, with each current <span class="math inline">I_i</span> divided by its distance from the recording electrode, <span class="math inline">d_e - d_i</span>. Stronger currents will tend to dominate over weaker ones. However, if there are a large number widely distributed of weak currents with similar waveforms then when added together they can produce a prominent potential.</p>
</section>
<section id="modeling-the-relationship-between-electrode-distance-and-recorded-potential" class="level3">
<h3 class="anchored" data-anchor-id="modeling-the-relationship-between-electrode-distance-and-recorded-potential">Modeling the relationship between electrode distance and recorded potential</h3>
<p>Using our <code>SynapticNeuron</code> model, we can explore how different types of neural activity are detected by extracellular electrodes. This model will simulate a collection of neurons arranged in a circular sheet. To capture the kinds of activities observed in the brain, we will include a slow global fluctuation in membrane potential across all the neurons (<code>slow_noise</code>), noise that is unique to each neuron (<code>noise</code>), and a pulse of synaptic drive (<code>mean_t</code> and <code>std_t</code>). It will also require a method to calculate the extracellular potential, using equation 6 (<code>calc_extracell</code>).</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
A caveat to our extracellular recording model
</div>
</div>
<div class="callout-body-container callout-body">
<p>The extracellular recording model we implement below is technically incorrect. Recall that Kirchoff’s current law requires the total current flowing into a point in a circuit to equal the amount flowing out. For our extracellular model, we measure the current flowing across the membrane on the extracellular side, which is composed of all the passive, action potential, and synaptic currents, which must sum to 0. This means that the total current flowing across the membrane in our model is 0, which would produce no extracellular field given equation 6. So, why do we detect extracellular potentials in the real world? This is because neurons are composed of more than just their cell body. They also have dendrites and axons. This allows currents to flow not only across the membrane, but also within the neuron itself. Thus, the total current flowing across a single segment of the membrane does not have to balance, since part of that current will flow inside the neuron to another part of the neuron, and eventually flow out of the membrane in a different segment. If you want to realistically model the extracellular field, this requires your neuron model to have multiple compartments that are connected together, each modeled using the formalism we use here. In contrast, our model is a <em>single compartment model</em>. To get an extracellular field, we will just measure the leak current, which responds to all the other currents crossing the membrane.</p>
</div>
</div>
<div id="be152ab2" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ExtracellRec():</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># class for extracellular recording of a sheet of neurons using the SynapticNeuron class</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># user can set the radius of the sheet, the density of neurons, the mean time and standard deviation </span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># around when a synaptic input arrives, the level of a shared slow input noise, and an individual gaussian noise</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># level for each neuron, electrode distance from the sheet</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, radius<span class="op">=</span><span class="dv">2</span>, density<span class="op">=</span><span class="dv">1000</span>, mean_t<span class="op">=</span><span class="fl">0.1</span>, std_t<span class="op">=</span><span class="fl">0.005</span>, slow_noise<span class="op">=</span><span class="dv">25</span>, <span class="op">\</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>                 noise<span class="op">=</span><span class="dv">200</span>, extra_cond<span class="op">=</span><span class="fl">0.3</span>, <span class="op">**</span>kwargs):</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._radius <span class="op">=</span> radius <span class="co"># cm</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._density <span class="op">=</span> density <span class="co"># neurons per cm^2</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._mean_t <span class="op">=</span> mean_t <span class="co"># sec</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._std_t <span class="op">=</span> std_t <span class="co"># sec</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._slow_noise <span class="op">=</span> slow_noise <span class="op">*</span> <span class="fl">1e-12</span> <span class="co"># slow shared noise standard deviation in pA</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._noise <span class="op">=</span> noise <span class="op">*</span> <span class="fl">1e-12</span> <span class="co"># individual neuron gaussian standard deviation in pA</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._extra_cond <span class="op">=</span> extra_cond <span class="co"># extracellular conductivity in S/m</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._v <span class="op">=</span> [] <span class="co"># voltage array</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._i <span class="op">=</span> [] <span class="co"># current array</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._t <span class="op">=</span> [] <span class="co"># time array</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># calculate number of neurons</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._n_neurons <span class="op">=</span> <span class="bu">int</span>(np.<span class="bu">round</span>(np.pi <span class="op">*</span> <span class="va">self</span>._radius<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>._density))</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># calculate positions of neurons, uniformly distributed in the circular sheet</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># place each neuron by setting a random angle and radius from the center</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._neuron_pos <span class="op">=</span> np.zeros((<span class="va">self</span>._n_neurons, <span class="dv">2</span>))</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ind <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>._n_neurons):</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>            curr_ang <span class="op">=</span> np.random.rand() <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> np.pi</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>            curr_rad <span class="op">=</span> np.sqrt(np.random.rand()) <span class="op">*</span> <span class="va">self</span>._radius</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._neuron_pos[ind, <span class="dv">0</span>] <span class="op">=</span> np.cos(curr_ang) <span class="op">*</span> curr_rad</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._neuron_pos[ind, <span class="dv">1</span>] <span class="op">=</span> np.sin(curr_ang) <span class="op">*</span> curr_rad</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># force one neuron to be at the center, so it can be easily picked up by the electrode</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._neuron_pos[<span class="dv">0</span>, :] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create neurons</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._neurons <span class="op">=</span> []</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ind <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>._n_neurons):</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._neurons.append(SynapticNeuron(<span class="op">**</span>kwargs))</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># method to calculate extracellular potential based on currents from each neuron</span></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calc_extracell(<span class="va">self</span>, h<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>        dists <span class="op">=</span> np.sqrt(np.<span class="bu">sum</span>(<span class="va">self</span>._neuron_pos<span class="op">**</span><span class="dv">2</span>,axis<span class="op">=</span><span class="dv">1</span>)<span class="op">+</span>h<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span><span class="va">self</span>._extra_cond) <span class="op">*</span> np.<span class="bu">sum</span>((<span class="va">self</span>._i.T <span class="op">*</span> <span class="fl">1e-9</span>) <span class="op">/</span> dists, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create run function that will run all neurons for a given duration</span></span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run(<span class="va">self</span>, dur<span class="op">=</span><span class="fl">0.2</span>, dt<span class="op">=</span><span class="fl">0.0001</span>, seed<span class="op">=</span><span class="dv">47</span>):</span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># set random seed</span></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>        np.random.seed(seed)</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># initialize arrays to store values</span></span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> <span class="va">self</span>._neurons[<span class="dv">0</span>].get_t_vec(dur, dt) <span class="co"># time array</span></span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a>        num_t <span class="op">=</span> <span class="bu">len</span>(t)</span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> np.zeros((<span class="va">self</span>._n_neurons, num_t)) <span class="co"># voltage array</span></span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> np.zeros((<span class="va">self</span>._n_neurons, num_t)) <span class="co"># current array</span></span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create synaptic inputs</span></span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a>        in_prespk <span class="op">=</span> []</span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ind <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>._n_neurons):</span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a>            in_prespk.append(spk_train(t, np.random.normal(<span class="va">self</span>._mean_t, <span class="va">self</span>._std_t, <span class="dv">1</span>)))</span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create slow noise input</span></span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a>        slow_noise <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, num_t)</span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a>        slow_noise <span class="op">=</span> sig.detrend(np.cumsum(slow_noise))</span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a>        slow_noise <span class="op">=</span> (slow_noise<span class="op">/</span>(np.std(slow_noise))) <span class="op">*</span> <span class="va">self</span>._slow_noise</span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-67"><a href="#cb30-67" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create individual noise inputs</span></span>
<span id="cb30-68"><a href="#cb30-68" aria-hidden="true" tabindex="-1"></a>        indiv_noise <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="va">self</span>._noise, (<span class="va">self</span>._n_neurons, <span class="bu">len</span>(t)))</span>
<span id="cb30-69"><a href="#cb30-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-70"><a href="#cb30-70" aria-hidden="true" tabindex="-1"></a>        <span class="co"># run simulation</span></span>
<span id="cb30-71"><a href="#cb30-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ind, curr_nrn <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>._neurons):</span>
<span id="cb30-72"><a href="#cb30-72" aria-hidden="true" tabindex="-1"></a>            inp_sig <span class="op">=</span> slow_noise <span class="op">+</span> indiv_noise[ind, :]</span>
<span id="cb30-73"><a href="#cb30-73" aria-hidden="true" tabindex="-1"></a>            v[ind, :], i[ind, :] <span class="op">=</span> curr_nrn.run(dur<span class="op">=</span>dur, dt<span class="op">=</span>dt, inp<span class="op">=</span>inp_sig, prespk<span class="op">=</span>in_prespk[ind])</span>
<span id="cb30-74"><a href="#cb30-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-75"><a href="#cb30-75" aria-hidden="true" tabindex="-1"></a>        <span class="co"># save simulation results</span></span>
<span id="cb30-76"><a href="#cb30-76" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._t <span class="op">=</span> t</span>
<span id="cb30-77"><a href="#cb30-77" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._v <span class="op">=</span> v</span>
<span id="cb30-78"><a href="#cb30-78" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._i <span class="op">=</span> i</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now that our simulation class is all setup, let’s use it. We will create a sheet of neurons with a radius of 2 cm and 1000 neurons per cm<sup>2</sup>. Using <code>**kwargs</code>, we are also able to pass arguments to <code>SynapticNeuron</code>, to configure its electrophysiological properties. We will take advantage of this by increasing the synaptic conductance, <code>gsyn</code>, so that action potentials are more reliably driven. The timing of the presynaptic spikes is set by a normal distribution, with the mean time of their emission at 100 ms, and a standard deviation of 5 ms. Since the inputs to our model neurons are generated randomly, and we want to replicate our results, we will fix the random seed of the model to ensure that the same output is generated each time we run it.</p>
<div id="4d2fe4e1" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>test <span class="op">=</span> ExtracellRec(gsyn<span class="op">=</span><span class="fl">7e-9</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>test.run(seed<span class="op">=</span><span class="dv">41</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>That is all it took to run our simulation. The more neurons we include, either by increasing the size of our sheet with the <code>radius</code> parameter or their packing with the <code>density</code> parameter, longer it takes to run. Once the simulation is finished running, we can calculate the extracellular potential for electrodes at different distances from the center of the model. We will choose a couple key values that are relevant to the recordings we will perform. An electrode on the scalp would be ~2 cm away from the surface of the brain. Intracranial surface electrodes that rest on the brain surface are picking up the activity of neurons with 0.5 mm. Lastly, depth electrodes that are inserted into the brain will detect neurons within tens of microns.</p>
<div id="c932bb6e" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>elec_dists <span class="op">=</span> [<span class="dv">2</span>, <span class="fl">0.05</span>, <span class="fl">0.001</span>] <span class="co"># cm</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>dist_labels <span class="op">=</span> [<span class="st">'2 cm'</span>, <span class="st">'0.5 mm'</span>, <span class="st">'10 um'</span>]</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="bu">len</span>(elec_dists),<span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">12</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ind, curr_dist <span class="kw">in</span> <span class="bu">enumerate</span>(elec_dists):</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    ax[ind].plot(test._t<span class="op">*</span><span class="fl">1e3</span>, test.calc_extracell(h<span class="op">=</span>curr_dist)<span class="op">*</span><span class="fl">1e6</span>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    ax[ind].set_title(dist_labels[ind])</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    ax[ind].set_xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    ax[ind].set_ylabel(<span class="st">'Extracellular potential (uV)'</span>)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-26-output-1.png" width="470" height="1142" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Each of these distances reveal different features of neural activity. The most obvious difference is that the signals tend to get larger as the electrode is moved closer to the sheet of neurons. At 2 cm, slow potentials, both the slow global signal and the synaptic drive, are evident. Then, moving to 0.5 mm we start to pick up some weak local spiking, and still can reliably detect synaptic currents. Note that the weak spiking we see is concentrated at the peak of the synaptic drive, with numerous overlapping spikes filling in the negative trough made by the depolarizing synaptic current. If we push the electrode to within 10 um of a neuron, the action potential becomes the dominant part of the signal. While the synaptic current is still visible prior to the spike, it is masked by the action potential once that occurs.</p>
<p>And going a little further, we can push the electrode right against the cell body of the neuron. This is <em>juxtacellular</em> recording, and it has a distinctive appearance where global and synaptic potentials are towered over by the robust currents generated by the action potential.</p>
<div id="bbeda210" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>plt.plot(test._t<span class="op">*</span><span class="fl">1e3</span>, test.calc_extracell(h<span class="op">=</span><span class="fl">0.0001</span>)<span class="op">*</span><span class="fl">1e6</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'1 um'</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Extracellular potential (uV)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>Text(0, 0.5, 'Extracellular potential (uV)')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Week1_files/figure-html/cell-27-output-2.png" width="596" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>